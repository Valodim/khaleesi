#![allow(bad_style)]

#[link(name = "ical")]
extern "C" {
}

/* automatically generated by rust-bindgen */

pub const ICAL_PACKAGE: &'static [u8; 8usize] = b"libical\0";
pub const ICAL_VERSION: &'static [u8; 4usize] = b"3.0\0";
pub const ICAL_MAJOR_VERSION: u32 = 3;
pub const ICAL_MINOR_VERSION: u32 = 0;
pub const ICAL_PATCH_VERSION: u32 = 4;
pub const ICAL_MICRO_VERSION: u32 = 4;
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const ICAL_BY_SECOND_SIZE: u32 = 62;
pub const ICAL_BY_MINUTE_SIZE: u32 = 61;
pub const ICAL_BY_HOUR_SIZE: u32 = 25;
pub const ICAL_BY_MONTH_SIZE: u32 = 14;
pub const ICAL_BY_MONTHDAY_SIZE: u32 = 32;
pub const ICAL_BY_WEEKNO_SIZE: u32 = 56;
pub const ICAL_BY_YEARDAY_SIZE: u32 = 386;
pub const ICAL_BY_SETPOS_SIZE: u32 = 386;
pub const ICAL_BY_DAY_SIZE: u32 = 386;
pub const ICALPROPERTY_FIRST_ENUM: u32 = 10000;
pub const ICALPROPERTY_LAST_ENUM: u32 = 11300;
pub const ICALPARAMETER_FIRST_ENUM: u32 = 20000;
pub const ICALPARAMETER_LAST_ENUM: u32 = 22300;
pub const ICAL_BOOLEAN_TRUE: u32 = 1;
pub const ICAL_BOOLEAN_FALSE: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const ZONES_TAB_SYSTEM_FILENAME: &'static [u8; 9usize] = b"zone.tab\0";
pub const _ASSERT_H: u32 = 1;
pub const ICAL_ERRORS_ARE_FATAL: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _icaltimezone {
    _unused: [u8; 0],
}
pub type icaltimezone = _icaltimezone;
/// icaltime_span is returned by icalcomponent_get_span()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaltime_span {
    ///< in UTC
    pub start: time_t,
    ///< in UTC
    pub end: time_t,
    ///< 1->busy time, 0-> free time
    pub is_busy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_icaltime_span() {
    assert_eq!(
        ::std::mem::size_of::<icaltime_span>(),
        24usize,
        concat!("Size of: ", stringify!(icaltime_span))
    );
    assert_eq!(
        ::std::mem::align_of::<icaltime_span>(),
        8usize,
        concat!("Alignment of ", stringify!(icaltime_span))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltime_span>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltime_span),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltime_span>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltime_span),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltime_span>())).is_busy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltime_span),
            "::",
            stringify!(is_busy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaltimetype {
    ///< Actual year, e.g. 2001.
    pub year: ::std::os::raw::c_int,
    ///< 1 (Jan) to 12 (Dec).
    pub month: ::std::os::raw::c_int,
    pub day: ::std::os::raw::c_int,
    pub hour: ::std::os::raw::c_int,
    pub minute: ::std::os::raw::c_int,
    pub second: ::std::os::raw::c_int,
    ///< 1 -> interpret this as date.
    pub is_date: ::std::os::raw::c_int,
    ///< 1 -> time is in daylight savings time.
    pub is_daylight: ::std::os::raw::c_int,
    ///< timezone
    pub zone: *const icaltimezone,
}
#[test]
fn bindgen_test_layout_icaltimetype() {
    assert_eq!(
        ::std::mem::size_of::<icaltimetype>(),
        40usize,
        concat!("Size of: ", stringify!(icaltimetype))
    );
    assert_eq!(
        ::std::mem::align_of::<icaltimetype>(),
        8usize,
        concat!("Alignment of ", stringify!(icaltimetype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).hour as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).minute as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).second as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).is_date as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(is_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).is_daylight as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(is_daylight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimetype>())).zone as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimetype),
            "::",
            stringify!(zone)
        )
    );
}
extern "C" {
    /// Return a null time, which indicates no time has been set.
    ///This time represent the beginning of the epoch
    pub fn icaltime_null_time() -> icaltimetype;
}
extern "C" {
    /// Return a null date
    pub fn icaltime_null_date() -> icaltimetype;
}
extern "C" {
    /// Returns the current time in the given timezone, as an icaltimetype.
    pub fn icaltime_current_time_with_zone(zone: *const icaltimezone) -> icaltimetype;
}
extern "C" {
    /// Returns the current day as an icaltimetype, with is_date set.
    pub fn icaltime_today() -> icaltimetype;
}
extern "C" {
    /// Convert seconds past UNIX epoch to a timetype, using timezones.
    pub fn icaltime_from_timet_with_zone(
        tm: time_t,
        is_date: ::std::os::raw::c_int,
        zone: *const icaltimezone,
    ) -> icaltimetype;
}
extern "C" {
    /// create a time from an ISO format string
    pub fn icaltime_from_string(str: *const ::std::os::raw::c_char) -> icaltimetype;
}
extern "C" {
    /// Create a new time, given a day of year and a year.
    pub fn icaltime_from_day_of_year(
        doy: ::std::os::raw::c_int,
        year: ::std::os::raw::c_int,
    ) -> icaltimetype;
}
extern "C" {
    /// Returns the time as seconds past the UNIX epoch
    ///
    /// This function probably won't do what you expect.  In particular, you should
    /// only pass an icaltime in UTC, since no conversion is done.  Even in that case,
    /// it's probably better to just use icaltime_as_timet_with_zone().
    pub fn icaltime_as_timet(arg1: icaltimetype) -> time_t;
}
extern "C" {
    /// Return the time as seconds past the UNIX epoch, using timezones.
    pub fn icaltime_as_timet_with_zone(tt: icaltimetype, zone: *const icaltimezone) -> time_t;
}
extern "C" {
    /// Return a string represention of the time, in RFC5545 format.
    pub fn icaltime_as_ical_string(tt: icaltimetype) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icaltime_as_ical_string_r(tt: icaltimetype) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Return the timezone
    pub fn icaltime_get_timezone(t: icaltimetype) -> *const icaltimezone;
}
extern "C" {
    /// @brief Return the tzid, or NULL for a floating time
    pub fn icaltime_get_tzid(t: icaltimetype) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Set the timezone
    pub fn icaltime_set_timezone(t: *mut icaltimetype, zone: *const icaltimezone) -> icaltimetype;
}
extern "C" {
    /// Return the day of the year of the given time
    pub fn icaltime_day_of_year(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the day of the week of the given time. Sunday is 1
    pub fn icaltime_day_of_week(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the day of the year for the first day of the week that the
    ///given time is within.
    pub fn icaltime_start_doy_week(
        t: icaltimetype,
        fdow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the week number for the week the given time is within
    pub fn icaltime_week_number(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return true of the time is null.
    pub fn icaltime_is_null_time(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Returns false if the time is clearly invalid, but is not null. This
    ///is usually the result of creating a new time type buy not clearing
    ///it, or setting one of the flags to an illegal value.
    pub fn icaltime_is_valid_time(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns true if time is of DATE type, false if DATE-TIME
    pub fn icaltime_is_date(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns true if time is relative to UTC zone
    pub fn icaltime_is_utc(t: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return -1, 0, or 1 to indicate that a is less than b, a equals b, or a is greater than b
    pub fn icaltime_compare(a: icaltimetype, b: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// like icaltime_compare, but only use the date parts.
    pub fn icaltime_compare_date_only(a: icaltimetype, b: icaltimetype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// like icaltime_compare, but only use the date parts.
    pub fn icaltime_compare_date_only_tz(
        a: icaltimetype,
        b: icaltimetype,
        tz: *mut icaltimezone,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Adds or subtracts a number of days, hours, minutes and seconds.
    pub fn icaltime_adjust(
        tt: *mut icaltimetype,
        days: ::std::os::raw::c_int,
        hours: ::std::os::raw::c_int,
        minutes: ::std::os::raw::c_int,
        seconds: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// Normalize the icaltime, so that all fields are within the normal range.
    pub fn icaltime_normalize(t: icaltimetype) -> icaltimetype;
}
extern "C" {
    /// convert tt, of timezone tzid, into a utc time. Does nothing if the
    ///time is already UTC.
    pub fn icaltime_convert_to_zone(tt: icaltimetype, zone: *mut icaltimezone) -> icaltimetype;
}
extern "C" {
    /// Return the number of days in the given month
    pub fn icaltime_days_in_month(
        month: ::std::os::raw::c_int,
        year: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return whether you've specified a leapyear or not.
    pub fn icaltime_is_leap_year(year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the number of days in this year
    pub fn icaltime_days_in_year(year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief calculate an icaltimespan given a start and end time.
    pub fn icaltime_span_new(
        dtstart: icaltimetype,
        dtend: icaltimetype,
        is_busy: ::std::os::raw::c_int,
    ) -> icaltime_span;
}
extern "C" {
    /// @brief Returns true if the two spans overlap
    pub fn icaltime_span_overlaps(
        s1: *mut icaltime_span,
        s2: *mut icaltime_span,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns true if the span is totally within the containing
    ///  span
    pub fn icaltime_span_contains(
        s: *mut icaltime_span,
        container: *mut icaltime_span,
    ) -> ::std::os::raw::c_int;
}
/// @brief A struct representing a duration
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaldurationtype {
    pub is_neg: ::std::os::raw::c_int,
    pub days: ::std::os::raw::c_uint,
    pub weeks: ::std::os::raw::c_uint,
    pub hours: ::std::os::raw::c_uint,
    pub minutes: ::std::os::raw::c_uint,
    pub seconds: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_icaldurationtype() {
    assert_eq!(
        ::std::mem::size_of::<icaldurationtype>(),
        24usize,
        concat!("Size of: ", stringify!(icaldurationtype))
    );
    assert_eq!(
        ::std::mem::align_of::<icaldurationtype>(),
        4usize,
        concat!("Alignment of ", stringify!(icaldurationtype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).is_neg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(is_neg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).days as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(days)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).weeks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(weeks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).hours as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).minutes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldurationtype>())).seconds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldurationtype),
            "::",
            stringify!(seconds)
        )
    );
}
extern "C" {
    /// @brief Creates a new ::icaldurationtype from a duration in seconds.
    /// @param t The duration in seconds
    /// @return An ::icaldurationtype representing the duration @a t in seconds
    ///
    /// ### Example
    /// ```c
    /// // create a new icaldurationtype with a duration of 60 seconds
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_from_int(60);
    ///
    /// // verify that the duration is one minute
    /// assert(duration.minutes == 1);
    /// ```
    pub fn icaldurationtype_from_int(t: ::std::os::raw::c_int) -> icaldurationtype;
}
extern "C" {
    /// @brief Creates a new ::icaldurationtype from a duration given as a string.
    /// @param dur The duration as a string
    /// @return An ::icaldurationtype representing the duration @a dur
    ///
    /// @par Error handling
    /// When given bad input, it sets ::icalerrno to ::ICAL_MALFORMEDDATA_ERROR and
    /// returnes icaldurationtype_bad_duration().
    ///
    /// ### Usage
    /// ```c
    /// // create a new icaldurationtype
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_from_string("+PT05M");
    ///
    /// // verify that it's 5 minutes
    /// assert(duration.minutes == 5);
    /// ```
    pub fn icaldurationtype_from_string(dur: *const ::std::os::raw::c_char) -> icaldurationtype;
}
extern "C" {
    /// @brief Converts an ::icaldurationtype into the duration in seconds as `int`.
    /// @param duration The duration to convert to seconds
    /// @return An `int` representing the duration in seconds
    ///
    /// ### Usage
    /// ```c
    /// // create icaldurationtype with given duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_from_int(3532342);
    ///
    /// // get the duration in seconds and verify it
    /// assert(icaldurationtype_as_int(duration) == 3532342);
    /// ```
    pub fn icaldurationtype_as_int(duration: icaldurationtype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Converts an icaldurationtype into the iCal format as string.
    /// @param The icaldurationtype to convert to iCal format
    /// @return A string representing duration @p d in iCal format
    /// @sa icaldurationtype_as_ical_string_r()
    ///
    /// @b Ownership
    /// The string returned by this function is owned by the caller and needs to be
    /// released with `free()` after it's no longer needed.
    ///
    /// @b Usage
    /// ```c
    /// // create new duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_from_int(3424224);
    ///
    /// // print as ical-formatted string
    /// char *ical = icaldurationtype_as_ical_string(duration);
    /// printf("%s\n", ical);
    ///
    /// // release string
    /// free(ical);
    /// ```
    pub fn icaldurationtype_as_ical_string(d: icaldurationtype) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Converts an icaldurationtype into the iCal format as string.
    /// @param The icaldurationtype to convert to iCal format
    /// @return A string representing duration @p d in iCal format
    /// @sa icaldurationtype_as_ical_string()
    ///
    /// @b Ownership
    /// The string returned by this function is owned by libical and must not be
    /// released by the caller of the function.
    ///
    /// @b Usage
    /// ```c
    /// // create new duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_from_int(3424224);
    ///
    /// // print as ical-formatted string
    /// printf("%s\n", icaldurationtype_as_ical_string(duration));
    /// ```
    pub fn icaldurationtype_as_ical_string_r(d: icaldurationtype) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Creates a duration with zero length.
    /// @return An ::icaldurationtype with a zero length
    /// @sa icaldurationtype_is_null_duration()
    ///
    /// ### Usage
    /// ```c
    /// // create null duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_null_duration();
    ///
    /// // make sure it's zero length
    /// assert(duration.days     == 0);
    /// assert(duration.weeks    == 0);
    /// assert(duration.hours    == 0);
    /// assert(duration.minutes  == 0);
    /// assert(duration.seconds  == 0);
    /// assert(icalduration_is_null_duration(duration));
    /// assert(icalduration_as_int(duration) == 0);
    /// ```
    pub fn icaldurationtype_null_duration() -> icaldurationtype;
}
extern "C" {
    /// @brief Creates a bad duration (used to indicate error).
    /// @return A bad duration
    /// @sa icaldurationtype_is_bad_duration()
    ///
    /// ### Usage
    /// ```c
    /// // create bad duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_bad_duration();
    ///
    /// // make sure it's bad
    /// assert(icaldurationtype_is_bad_duration(duration));
    /// ```
    pub fn icaldurationtype_bad_duration() -> icaldurationtype;
}
extern "C" {
    /// @brief Checks if a duration is a null duration.
    /// @param d The duration to check
    /// @return 1 if the duration is a null duration, 0 otherwise
    /// @sa icalduration_null_duration()
    ///
    /// ### Usage
    /// ```c
    /// // make null duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_null_duration();
    ///
    /// // check null duration
    /// assert(icaldurationtype_is_null_duration(duration));
    /// ```
    pub fn icaldurationtype_is_null_duration(d: icaldurationtype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Checks if a duration is a bad duration.
    /// @param d The duration to check
    /// @return 1 if the duration is a bad duration, 0 otherwise
    /// @sa icalduration_bad_duration()
    ///
    /// ### Usage
    /// ```c
    /// // make bad duration
    /// struct icaldurationtype duration;
    /// duration = icaldurationtype_bad_duration();
    ///
    /// // check bad duration
    /// assert(icaldurationtype_is_bad_duration(duration));
    /// ```
    pub fn icaldurationtype_is_bad_duration(d: icaldurationtype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Adds a duration to an ::icaltime object and returns the result.
    /// @param t The time object to add the duration to
    /// @param d The duration to add to the time object
    /// @return The new ::icaltimetype which has been added the duration to
    ///
    /// ### Example
    /// ```c
    /// struct icaltimetype time;
    /// struct icaldurationtype duration;
    ///
    /// // create time and duration objects
    /// time = icaltime_today();
    /// duration = icaldurationtype_from_int(60);
    ///
    /// // add the duration to the time object
    /// time = icaltime_add(time, duration);
    /// ```
    pub fn icaltime_add(t: icaltimetype, d: icaldurationtype) -> icaltimetype;
}
extern "C" {
    /// @brief Returns the difference between two ::icaltimetype as a duration.
    /// @param t1 The first point in time
    /// @param t2 The second point in time
    /// @return An ::icaldurationtype representing the duration the elapsed between
    /// @a t1 and @a t2
    ///
    /// ### Usage
    /// ```c
    /// struct icaltimetype t1 = icaltime_from_day_of_year(111, 2018);
    /// struct icaltimetype t2 = icaltime_from_day_of_year(112, 2018);
    /// struct icaldurationtype duration;
    ///
    /// // calculate duration between time points
    /// duration = icaltime_subtract(t1, t2);
    /// ```
    pub fn icaltime_subtract(t1: icaltimetype, t2: icaltimetype) -> icaldurationtype;
}
/// @brief Struct to represent a period in time.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalperiodtype {
    pub start: icaltimetype,
    pub end: icaltimetype,
    pub duration: icaldurationtype,
}
#[test]
fn bindgen_test_layout_icalperiodtype() {
    assert_eq!(
        ::std::mem::size_of::<icalperiodtype>(),
        104usize,
        concat!("Size of: ", stringify!(icalperiodtype))
    );
    assert_eq!(
        ::std::mem::align_of::<icalperiodtype>(),
        8usize,
        concat!("Alignment of ", stringify!(icalperiodtype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalperiodtype>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icalperiodtype),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalperiodtype>())).end as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(icalperiodtype),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalperiodtype>())).duration as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(icalperiodtype),
            "::",
            stringify!(duration)
        )
    );
}
extern "C" {
    /// @brief Constructs a new ::icalperiodtype from @a str
    /// @param str The string from which to construct a time period
    /// @return An ::icalperiodtype representing the peroid @a str
    /// @sa icaltime_from_string(), icaldurationtype_from_string()
    ///
    /// @par Error handling
    /// If @a str is not properly formatted, it sets ::icalerrno to
    /// ::ICAL_MALFORMEDDATA_ERROR and returns icalperiodtype_null_period().
    ///
    /// ### Data format
    /// There are two ways to specify a duration; either a start time
    /// and an end time can be specified, or a start time and a duration.
    /// The format for there is as such:
    /// -   `<STARTTIME>/<ENDTIME>`
    /// -   `<STARTTIME>/<DURATION>`
    ///
    /// The format for the times is the same as those used by
    /// icaltime_from_string(), and the format for the duration
    /// is the same as that used by icaldurationtype_from_string().
    ///
    /// ### Usage
    /// ```c
    /// // create icalperiodtype
    /// const char *period_string = "20170606T090000/20170607T090000";
    /// struct icalperiodtype period = icalperiodtype_from_string(period_string);
    ///
    /// // print period in iCal format
    /// printf("%s\n", icalperiodtype_as_ical_string(period));
    /// ```
    pub fn icalperiodtype_from_string(str: *const ::std::os::raw::c_char) -> icalperiodtype;
}
extern "C" {
    /// @brief Converts an ::icalperiodtype into an iCal-formatted string.
    /// @param p The time period to convert
    /// @return A string representing the iCal-formatted period
    /// @sa icalperiodtype_as_ical_string_r()
    ///
    /// @par Error handling
    /// Sets ::icalerrno to ::ICAL_ALLOCATION_ERROR if there was an
    /// internal error allocating memory.
    ///
    /// @par Ownership
    /// The string returned by this method is owned by libical and must not be
    /// `free()` by the caller.
    ///
    /// ### Example
    /// ```c
    /// // create icalperiodtype
    /// const char *period_string = "20170606T090000/20170607T090000";
    /// struct icalperiodtype period = icalperiodtype_from_string(period_string);
    ///
    /// // print period in iCal format
    /// printf("%s\n", icalperiodtype_as_ical_string(period));
    /// ```
    pub fn icalperiodtype_as_ical_string(p: icalperiodtype) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Converts an ::icalperiodtype into an iCal-formatted string.
    /// @param p The time period to convert
    /// @return A string representing the iCal-formatted period
    /// @sa icalperiodtype_as_ical_string()
    ///
    /// @par Error handling
    /// Sets ::icalerrno to ::ICAL_ALLOCATION_ERROR if there was an
    /// internal error allocating memory.
    ///
    /// @par Ownership
    /// The string returned by this method is owned by the caller and must be
    /// released with the appropriate function after use.
    ///
    /// ### Example
    /// ```c
    /// // create icalperiodtype
    /// const char *period_string = "20170606T090000/20170607T090000";
    /// struct icalperiodtype period = icalperiodtype_from_string(period_string);
    ///
    /// // print period in iCal format
    /// const char *period_string_gen = icalperiodtype_as_ical_string_r(period);
    /// printf("%s\n", period_string_gen);
    /// icalmemory_free_buffer(period_string_gen);
    /// ```
    pub fn icalperiodtype_as_ical_string_r(p: icalperiodtype) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Creates a null period ::icalperiodtype.
    /// @return An ::icalperiodtype representing a null period
    /// @sa icalperiodtype_is_null_period()
    ///
    /// ### Usage
    /// ```c
    /// // creates null period
    /// struct icalperiodtype period = icalperiodtype_null_period();
    ///
    /// // verifies start, end and length
    /// assert(icaltime_is_null_time(period.start));
    /// assert(icaltime_is_null_time(period.end));
    /// assert(icaldurationtype_is_null_duratino(period.duration));
    /// ```
    pub fn icalperiodtype_null_period() -> icalperiodtype;
}
extern "C" {
    /// Checks if a given ::icalperiodtype is a null period.
    /// @return 1 if @a p is a null period, 0 otherwise
    /// @sa icalperiodtype_null_period()
    ///
    /// ### Usage
    /// ```c
    /// // creates null period
    /// struct icalperiodtype period = icalperiodtype_null_period();
    ///
    /// // checks if it's a null period
    /// assert(icalperiodtype_is_null_period(period));
    /// ```
    pub fn icalperiodtype_is_null_period(p: icalperiodtype) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Checks if a given ::icalperiodtype is a valid period.
    /// @return 1 if @a p is a valid period, 0 otherwise
    ///
    /// ### Usage
    /// ```c
    /// // creates null period
    /// struct icalperiodtype period = icalperiodtype_null_period();
    ///
    /// // a null period isn't a valid period
    /// assert(icalperiodtype_is_valid_period(period) == 0);
    /// ```
    pub fn icalperiodtype_is_valid_period(p: icalperiodtype) -> ::std::os::raw::c_int;
}
pub const icalcomponent_kind_ICAL_NO_COMPONENT: icalcomponent_kind = 0;
pub const icalcomponent_kind_ICAL_ANY_COMPONENT: icalcomponent_kind = 1;
pub const icalcomponent_kind_ICAL_XROOT_COMPONENT: icalcomponent_kind = 2;
pub const icalcomponent_kind_ICAL_XATTACH_COMPONENT: icalcomponent_kind = 3;
pub const icalcomponent_kind_ICAL_VEVENT_COMPONENT: icalcomponent_kind = 4;
pub const icalcomponent_kind_ICAL_VTODO_COMPONENT: icalcomponent_kind = 5;
pub const icalcomponent_kind_ICAL_VJOURNAL_COMPONENT: icalcomponent_kind = 6;
pub const icalcomponent_kind_ICAL_VCALENDAR_COMPONENT: icalcomponent_kind = 7;
pub const icalcomponent_kind_ICAL_VAGENDA_COMPONENT: icalcomponent_kind = 8;
pub const icalcomponent_kind_ICAL_VFREEBUSY_COMPONENT: icalcomponent_kind = 9;
pub const icalcomponent_kind_ICAL_VALARM_COMPONENT: icalcomponent_kind = 10;
pub const icalcomponent_kind_ICAL_XAUDIOALARM_COMPONENT: icalcomponent_kind = 11;
pub const icalcomponent_kind_ICAL_XDISPLAYALARM_COMPONENT: icalcomponent_kind = 12;
pub const icalcomponent_kind_ICAL_XEMAILALARM_COMPONENT: icalcomponent_kind = 13;
pub const icalcomponent_kind_ICAL_XPROCEDUREALARM_COMPONENT: icalcomponent_kind = 14;
pub const icalcomponent_kind_ICAL_VTIMEZONE_COMPONENT: icalcomponent_kind = 15;
pub const icalcomponent_kind_ICAL_XSTANDARD_COMPONENT: icalcomponent_kind = 16;
pub const icalcomponent_kind_ICAL_XDAYLIGHT_COMPONENT: icalcomponent_kind = 17;
pub const icalcomponent_kind_ICAL_X_COMPONENT: icalcomponent_kind = 18;
pub const icalcomponent_kind_ICAL_VSCHEDULE_COMPONENT: icalcomponent_kind = 19;
pub const icalcomponent_kind_ICAL_VQUERY_COMPONENT: icalcomponent_kind = 20;
pub const icalcomponent_kind_ICAL_VREPLY_COMPONENT: icalcomponent_kind = 21;
pub const icalcomponent_kind_ICAL_VCAR_COMPONENT: icalcomponent_kind = 22;
pub const icalcomponent_kind_ICAL_VCOMMAND_COMPONENT: icalcomponent_kind = 23;
pub const icalcomponent_kind_ICAL_XLICINVALID_COMPONENT: icalcomponent_kind = 24;
pub const icalcomponent_kind_ICAL_XLICMIMEPART_COMPONENT: icalcomponent_kind = 25;
pub const icalcomponent_kind_ICAL_VAVAILABILITY_COMPONENT: icalcomponent_kind = 26;
pub const icalcomponent_kind_ICAL_XAVAILABLE_COMPONENT: icalcomponent_kind = 27;
pub const icalcomponent_kind_ICAL_VPOLL_COMPONENT: icalcomponent_kind = 28;
pub const icalcomponent_kind_ICAL_VVOTER_COMPONENT: icalcomponent_kind = 29;
pub const icalcomponent_kind_ICAL_XVOTE_COMPONENT: icalcomponent_kind = 30;
pub const icalcomponent_kind_ICAL_VPATCH_COMPONENT: icalcomponent_kind = 31;
pub const icalcomponent_kind_ICAL_XPATCH_COMPONENT: icalcomponent_kind = 32;
/// Component enumerations
pub type icalcomponent_kind = u32;
pub const icalrequeststatus_ICAL_UNKNOWN_STATUS: icalrequeststatus = 0;
pub const icalrequeststatus_ICAL_2_0_SUCCESS_STATUS: icalrequeststatus = 1;
pub const icalrequeststatus_ICAL_2_1_FALLBACK_STATUS: icalrequeststatus = 2;
pub const icalrequeststatus_ICAL_2_2_IGPROP_STATUS: icalrequeststatus = 3;
pub const icalrequeststatus_ICAL_2_3_IGPARAM_STATUS: icalrequeststatus = 4;
pub const icalrequeststatus_ICAL_2_4_IGXPROP_STATUS: icalrequeststatus = 5;
pub const icalrequeststatus_ICAL_2_5_IGXPARAM_STATUS: icalrequeststatus = 6;
pub const icalrequeststatus_ICAL_2_6_IGCOMP_STATUS: icalrequeststatus = 7;
pub const icalrequeststatus_ICAL_2_7_FORWARD_STATUS: icalrequeststatus = 8;
pub const icalrequeststatus_ICAL_2_8_ONEEVENT_STATUS: icalrequeststatus = 9;
pub const icalrequeststatus_ICAL_2_9_TRUNC_STATUS: icalrequeststatus = 10;
pub const icalrequeststatus_ICAL_2_10_ONETODO_STATUS: icalrequeststatus = 11;
pub const icalrequeststatus_ICAL_2_11_TRUNCRRULE_STATUS: icalrequeststatus = 12;
pub const icalrequeststatus_ICAL_3_0_INVPROPNAME_STATUS: icalrequeststatus = 13;
pub const icalrequeststatus_ICAL_3_1_INVPROPVAL_STATUS: icalrequeststatus = 14;
pub const icalrequeststatus_ICAL_3_2_INVPARAM_STATUS: icalrequeststatus = 15;
pub const icalrequeststatus_ICAL_3_3_INVPARAMVAL_STATUS: icalrequeststatus = 16;
pub const icalrequeststatus_ICAL_3_4_INVCOMP_STATUS: icalrequeststatus = 17;
pub const icalrequeststatus_ICAL_3_5_INVTIME_STATUS: icalrequeststatus = 18;
pub const icalrequeststatus_ICAL_3_6_INVRULE_STATUS: icalrequeststatus = 19;
pub const icalrequeststatus_ICAL_3_7_INVCU_STATUS: icalrequeststatus = 20;
pub const icalrequeststatus_ICAL_3_8_NOAUTH_STATUS: icalrequeststatus = 21;
pub const icalrequeststatus_ICAL_3_9_BADVERSION_STATUS: icalrequeststatus = 22;
pub const icalrequeststatus_ICAL_3_10_TOOBIG_STATUS: icalrequeststatus = 23;
pub const icalrequeststatus_ICAL_3_11_MISSREQCOMP_STATUS: icalrequeststatus = 24;
pub const icalrequeststatus_ICAL_3_12_UNKCOMP_STATUS: icalrequeststatus = 25;
pub const icalrequeststatus_ICAL_3_13_BADCOMP_STATUS: icalrequeststatus = 26;
pub const icalrequeststatus_ICAL_3_14_NOCAP_STATUS: icalrequeststatus = 27;
pub const icalrequeststatus_ICAL_3_15_INVCOMMAND: icalrequeststatus = 28;
pub const icalrequeststatus_ICAL_4_0_BUSY_STATUS: icalrequeststatus = 29;
pub const icalrequeststatus_ICAL_4_1_STORE_ACCESS_DENIED: icalrequeststatus = 30;
pub const icalrequeststatus_ICAL_4_2_STORE_FAILED: icalrequeststatus = 31;
pub const icalrequeststatus_ICAL_4_3_STORE_NOT_FOUND: icalrequeststatus = 32;
pub const icalrequeststatus_ICAL_5_0_MAYBE_STATUS: icalrequeststatus = 33;
pub const icalrequeststatus_ICAL_5_1_UNAVAIL_STATUS: icalrequeststatus = 34;
pub const icalrequeststatus_ICAL_5_2_NOSERVICE_STATUS: icalrequeststatus = 35;
pub const icalrequeststatus_ICAL_5_3_NOSCHED_STATUS: icalrequeststatus = 36;
pub const icalrequeststatus_ICAL_6_1_CONTAINER_NOT_FOUND: icalrequeststatus = 37;
pub const icalrequeststatus_ICAL_9_0_UNRECOGNIZED_COMMAND: icalrequeststatus = 38;
/// Request Status codes
pub type icalrequeststatus = u32;
extern "C" {
    pub fn icalenum_reqstat_desc(stat: icalrequeststatus) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalenum_reqstat_major(stat: icalrequeststatus) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn icalenum_reqstat_minor(stat: icalrequeststatus) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn icalenum_num_to_reqstat(
        major: ::std::os::raw::c_short,
        minor: ::std::os::raw::c_short,
    ) -> icalrequeststatus;
}
extern "C" {
    pub fn icalenum_reqstat_code(stat: icalrequeststatus) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalenum_reqstat_code_r(stat: icalrequeststatus) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaldatetimeperiodtype {
    pub time: icaltimetype,
    pub period: icalperiodtype,
}
#[test]
fn bindgen_test_layout_icaldatetimeperiodtype() {
    assert_eq!(
        ::std::mem::size_of::<icaldatetimeperiodtype>(),
        144usize,
        concat!("Size of: ", stringify!(icaldatetimeperiodtype))
    );
    assert_eq!(
        ::std::mem::align_of::<icaldatetimeperiodtype>(),
        8usize,
        concat!("Alignment of ", stringify!(icaldatetimeperiodtype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldatetimeperiodtype>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldatetimeperiodtype),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaldatetimeperiodtype>())).period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(icaldatetimeperiodtype),
            "::",
            stringify!(period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalgeotype {
    pub lat: f64,
    pub lon: f64,
}
#[test]
fn bindgen_test_layout_icalgeotype() {
    assert_eq!(
        ::std::mem::size_of::<icalgeotype>(),
        16usize,
        concat!("Size of: ", stringify!(icalgeotype))
    );
    assert_eq!(
        ::std::mem::align_of::<icalgeotype>(),
        8usize,
        concat!("Alignment of ", stringify!(icalgeotype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalgeotype>())).lat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icalgeotype),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalgeotype>())).lon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icalgeotype),
            "::",
            stringify!(lon)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaltriggertype {
    pub time: icaltimetype,
    pub duration: icaldurationtype,
}
#[test]
fn bindgen_test_layout_icaltriggertype() {
    assert_eq!(
        ::std::mem::size_of::<icaltriggertype>(),
        64usize,
        concat!("Size of: ", stringify!(icaltriggertype))
    );
    assert_eq!(
        ::std::mem::align_of::<icaltriggertype>(),
        8usize,
        concat!("Alignment of ", stringify!(icaltriggertype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltriggertype>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltriggertype),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltriggertype>())).duration as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltriggertype),
            "::",
            stringify!(duration)
        )
    );
}
extern "C" {
    pub fn icaltriggertype_from_int(reltime: ::std::os::raw::c_int) -> icaltriggertype;
}
extern "C" {
    pub fn icaltriggertype_from_string(str: *const ::std::os::raw::c_char) -> icaltriggertype;
}
extern "C" {
    pub fn icaltriggertype_is_null_trigger(tr: icaltriggertype) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icaltriggertype_is_bad_trigger(tr: icaltriggertype) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalreqstattype {
    pub code: icalrequeststatus,
    pub desc: *const ::std::os::raw::c_char,
    pub debug: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_icalreqstattype() {
    assert_eq!(
        ::std::mem::size_of::<icalreqstattype>(),
        24usize,
        concat!("Size of: ", stringify!(icalreqstattype))
    );
    assert_eq!(
        ::std::mem::align_of::<icalreqstattype>(),
        8usize,
        concat!("Alignment of ", stringify!(icalreqstattype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalreqstattype>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icalreqstattype),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalreqstattype>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icalreqstattype),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalreqstattype>())).debug as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icalreqstattype),
            "::",
            stringify!(debug)
        )
    );
}
extern "C" {
    pub fn icalreqstattype_from_string(str: *const ::std::os::raw::c_char) -> icalreqstattype;
}
extern "C" {
    pub fn icalreqstattype_as_string(arg1: icalreqstattype) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalreqstattype_as_string_r(arg1: icalreqstattype) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaltimezonephase {
    pub tzname: *const ::std::os::raw::c_char,
    pub is_stdandard: ::std::os::raw::c_int,
    pub dtstart: icaltimetype,
    pub offsetto: ::std::os::raw::c_int,
    pub tzoffsetfrom: ::std::os::raw::c_int,
    pub comment: *const ::std::os::raw::c_char,
    pub rdate: icaldatetimeperiodtype,
    pub rrule: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_icaltimezonephase() {
    assert_eq!(
        ::std::mem::size_of::<icaltimezonephase>(),
        224usize,
        concat!("Size of: ", stringify!(icaltimezonephase))
    );
    assert_eq!(
        ::std::mem::align_of::<icaltimezonephase>(),
        8usize,
        concat!("Alignment of ", stringify!(icaltimezonephase))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).tzname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(tzname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).is_stdandard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(is_stdandard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).dtstart as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(dtstart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).offsetto as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(offsetto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).tzoffsetfrom as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(tzoffsetfrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).comment as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).rdate as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(rdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonephase>())).rrule as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonephase),
            "::",
            stringify!(rrule)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icaltimezonetype {
    pub tzid: *const ::std::os::raw::c_char,
    pub last_mod: icaltimetype,
    pub tzurl: *const ::std::os::raw::c_char,
    pub phases: *mut icaltimezonephase,
}
#[test]
fn bindgen_test_layout_icaltimezonetype() {
    assert_eq!(
        ::std::mem::size_of::<icaltimezonetype>(),
        64usize,
        concat!("Size of: ", stringify!(icaltimezonetype))
    );
    assert_eq!(
        ::std::mem::align_of::<icaltimezonetype>(),
        8usize,
        concat!("Alignment of ", stringify!(icaltimezonetype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonetype>())).tzid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonetype),
            "::",
            stringify!(tzid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonetype>())).last_mod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonetype),
            "::",
            stringify!(last_mod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonetype>())).tzurl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonetype),
            "::",
            stringify!(tzurl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icaltimezonetype>())).phases as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(icaltimezonetype),
            "::",
            stringify!(phases)
        )
    );
}
pub const ical_unknown_token_handling_ICAL_ASSUME_IANA_TOKEN: ical_unknown_token_handling = 1;
pub const ical_unknown_token_handling_ICAL_DISCARD_TOKEN: ical_unknown_token_handling = 2;
pub const ical_unknown_token_handling_ICAL_TREAT_AS_ERROR: ical_unknown_token_handling = 3;
pub type ical_unknown_token_handling = u32;
extern "C" {
    pub fn ical_get_unknown_token_handling_setting() -> ical_unknown_token_handling;
}
extern "C" {
    pub fn ical_set_unknown_token_handling_setting(newSetting: ical_unknown_token_handling);
}
/// @typedef icalarray
/// @brief A struct representing an icalarray object
pub type icalarray = _icalarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _icalarray {
    pub element_size: usize,
    pub increment_size: usize,
    pub num_elements: usize,
    pub space_allocated: usize,
    pub chunks: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__icalarray() {
    assert_eq!(
        ::std::mem::size_of::<_icalarray>(),
        40usize,
        concat!("Size of: ", stringify!(_icalarray))
    );
    assert_eq!(
        ::std::mem::align_of::<_icalarray>(),
        8usize,
        concat!("Alignment of ", stringify!(_icalarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_icalarray>())).element_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_icalarray),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_icalarray>())).increment_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_icalarray),
            "::",
            stringify!(increment_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_icalarray>())).num_elements as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_icalarray),
            "::",
            stringify!(num_elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_icalarray>())).space_allocated as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_icalarray),
            "::",
            stringify!(space_allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_icalarray>())).chunks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_icalarray),
            "::",
            stringify!(chunks)
        )
    );
}
extern "C" {
    /// @brief Creates new ::icalarray object.
    /// @param element_size The size of the elements to be held by the array
    /// @param increment_size How many extra elements worth of space to allocate on expansion
    /// @return The new ::icalarray object
    /// @sa icalarray_free()
    ///
    /// Creates a new ::icalarray object. The parameter @a element_size determines
    /// the size of the elements that the array will hold (in bytes). The parameter
    /// @a increment_size determines how many extra elements to be allocated when
    /// expanding the array for performance reasons (expansions are expensive, since
    /// it involves copying all existing elements).
    ///
    /// @par Error handling
    /// If @a element_size or @a increment_size is not at least 1, using the ::icalarray
    /// object results in undefined behaviour. If there is an error while creating the
    /// object, it returns `NULL` and sets ::icalerrno to ::ICAL_NEWFAILED_ERROR.
    ///
    /// @par Ownership
    /// The returned ::icalarray object is owned by the caller of the function,
    /// and needs to be released properly after it's no longer needed with
    /// icalarray_free().
    ///
    /// ### Usage
    /// ```c
    /// // create new array
    /// icalarray *array = icalarray_new(sizeof(int), 1);
    ///
    /// // use array
    /// int a = 4;
    /// icalarray_append(array, &a);
    /// assert(*icalarray_element_at(array, 0) == a);
    ///
    /// // release memory
    /// icalarray_free(array);
    /// ```
    pub fn icalarray_new(element_size: usize, increment_size: usize) -> *mut icalarray;
}
extern "C" {
    /// @brief Copies an existing ::icalarray and it's elements, creating a new one.
    /// @param array The array to copy
    /// @return A new array, holding all the elements of @a array
    ///
    /// Creates a new ::icalarray object, copying all the existing elements from
    /// @a array as well as it's properties (such as @a element_size and
    /// @a increment_size) over.
    ///
    /// @par Error handling
    /// If @a array is `NULL`, this method will return `NULL`. If there was an error
    /// allocating memory while creating the copy, it will set ::icalerrno
    /// to ::ICAL_ALLOCATION_ERROR.
    ///
    /// @par Ownership
    /// The created copy is owned by the caller of the function, and needs to
    /// be released with icalarray_free() after it's no longer being used.
    ///
    /// ### Usage
    /// ```c
    /// // create new array
    /// icalarray *array = icalarray_new(sizeof(int), 1);
    ///
    /// // fill array
    /// int a = 4;
    /// icalarray_append(array, &a);
    ///
    /// // create copy of array
    /// icalarray *copy = icalarray_copy(array);
    /// assert(*icalarray_element_at(copy, 0) == a);
    ///
    /// // release arrays
    /// icalarray_free(array);
    /// icalarray_free(copy);
    /// ```
    pub fn icalarray_copy(array: *mut icalarray) -> *mut icalarray;
}
extern "C" {
    /// @brief Frees an array object and everything that it contains.
    /// @param array The array to release
    ///
    /// ### Example
    /// ```c
    /// // creating an array
    /// icalarray *array = icalarray_new(sizeof(int), 1);
    ///
    /// // releasing it
    /// icalarray_free(array);
    /// ```
    pub fn icalarray_free(array: *mut icalarray);
}
extern "C" {
    /// @brief Appends an element to an array.
    /// @param array The array to append the element to
    /// @param element The element to append
    ///
    /// Appends the given @a element to the @a array, reallocating
    /// and expanding the array as needed.
    ///
    /// @par Error handling
    /// If @a array or @a element is `NULL`, using this function results
    /// in undefined behaviour (most likely a segfault).
    ///
    /// @par Ownership
    /// The @a element does not get consumed by the method, since it creates
    /// a copy of it
    ///
    /// ### Usage
    /// ```c
    /// // create new array
    /// icalarray *array = icalarray_new(sizeof(int), 1);
    ///
    /// // append data to it
    /// int data = 42;
    /// icalarray_append(array, &data);
    ///
    /// // release array
    /// icalarray_free(array);
    /// ```
    pub fn icalarray_append(array: *mut icalarray, element: *const ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Removes a given element from an array.
    /// @brief array The array from which to remove the element
    /// @brief position The position of the element to remove
    ///
    /// Removes the element at the given position from the array.
    ///
    /// @par Error handling
    /// If @a array is `NULL`, using this function results in undefined behaviour.
    /// If the array is empty, using this functino results in undefined behaviour.
    /// If the @a position is non-existent, it removes the last element.
    ///
    /// ### Usage
    /// ```c
    /// // create new array
    /// icalarray *array = icalarray_new(sizeof(int), 2);
    ///
    /// // fill array
    /// int data;
    /// data = 4;
    /// icalarray_append(array, &a);
    /// data = 9;
    /// icalarray_append(array, &a);
    /// data = 7;
    /// icalarray_append(array, &a);
    /// data = 10;
    /// icalarray_append(array, &a);
    ///
    /// // check array
    /// assert(*icalarray_element_at(array, 0) == 4);
    /// assert(*icalarray_element_at(array, 1) == 9);
    /// assert(*icalarray_element_at(array, 2) == 7);
    /// assert(*icalarray_element_at(array, 3) == 10);
    ///
    /// // remove the second element
    /// icalarray_remove_element_at(array, 1);
    ///
    /// // check array
    /// assert(*icalarray_element_at(array, 0) == 4);
    /// assert(*icalarray_element_at(array, 1) == 7);
    /// assert(*icalarray_element_at(array, 2) == 10);
    ///
    /// // release array
    /// icalarray_free(array);
    /// ```
    pub fn icalarray_remove_element_at(array: *mut icalarray, position: usize);
}
extern "C" {
    /// @brief Access an array element
    /// @param array The array object in which the element is stored
    /// @param position The position of the element to access in the array
    /// @return A pointer to the element inside the array
    ///
    /// Accesses an array element by returning a pointer to it, given an
    /// @a array and a valid element @a position.
    ///
    /// @par Error handling
    /// If @a array is `NULL`, using this function results in undefined behaviour.
    /// If @a position is not a valid position in the array, using this function
    /// results in undefined behaviour.
    ///
    /// @par Ownership
    /// The element is owned by the ::icalarray, it must not be freed by
    /// the user.
    ///
    /// ### Usage
    /// ```c
    /// // create new array
    /// icalarray *array = icalarray_new(sizeof(int), 1);
    ///
    /// // fill array
    /// int a = 4;
    /// icalarray_append(array, &a);
    ///
    /// // access array element
    /// int *element = icalarray_element_at(array, 0);
    /// assert(element != NULL);
    /// assert(*element == a);
    ///
    /// // change array element
    /// *element = 14;
    /// assert(*icalarray_element(array) == 14);
    ///
    /// // release memory
    /// icalarray_free(array);
    /// ```
    pub fn icalarray_element_at(
        array: *mut icalarray,
        position: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Sorts the elements of an ::icalarray using the given comparison function.
    /// @param array The array to sort
    /// @param compare The comparison function to use
    ///
    /// @par Error handling
    /// Passing `NULL` as either @a array or @a compare results in undefined
    /// behaviour.
    ///
    /// ### Usage
    /// ```c
    /// int compare_ints(const void *a, const void *b) {
    ///     return *((int*)a) - *((int*)b);
    /// }
    ///
    /// int main(int argc, char *argv[]) {
    ///     int numbers[] = {5, 2, 7, 4, 3, 1, 0, 8, 6, 9};
    ///
    ///     icalarray *array = icalarray_new(sizeof(int), 3);
    ///
    ///     // fill array
    ///     for(int i = 0; i < 10; i++) {
    ///         icalarray_append(array, &numbers[i]);
    ///     }
    ///
    ///     // sort array
    ///     icalarray_sort(array, compare_ints);
    ///
    ///     // print numbers
    ///     for(int i = 0; i < 10; i++) {
    ///         printf("%i\n", *((int*)icalarray_element_at(array, i)));
    ///     }
    ///
    ///     return 0;
    /// }
    /// ```
    pub fn icalarray_sort(
        array: *mut icalarray,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
pub const icalrecurrencetype_frequency_ICAL_SECONDLY_RECURRENCE: icalrecurrencetype_frequency = 0;
pub const icalrecurrencetype_frequency_ICAL_MINUTELY_RECURRENCE: icalrecurrencetype_frequency = 1;
pub const icalrecurrencetype_frequency_ICAL_HOURLY_RECURRENCE: icalrecurrencetype_frequency = 2;
pub const icalrecurrencetype_frequency_ICAL_DAILY_RECURRENCE: icalrecurrencetype_frequency = 3;
pub const icalrecurrencetype_frequency_ICAL_WEEKLY_RECURRENCE: icalrecurrencetype_frequency = 4;
pub const icalrecurrencetype_frequency_ICAL_MONTHLY_RECURRENCE: icalrecurrencetype_frequency = 5;
pub const icalrecurrencetype_frequency_ICAL_YEARLY_RECURRENCE: icalrecurrencetype_frequency = 6;
pub const icalrecurrencetype_frequency_ICAL_NO_RECURRENCE: icalrecurrencetype_frequency = 7;
pub type icalrecurrencetype_frequency = u32;
pub const icalrecurrencetype_weekday_ICAL_NO_WEEKDAY: icalrecurrencetype_weekday = 0;
pub const icalrecurrencetype_weekday_ICAL_SUNDAY_WEEKDAY: icalrecurrencetype_weekday = 1;
pub const icalrecurrencetype_weekday_ICAL_MONDAY_WEEKDAY: icalrecurrencetype_weekday = 2;
pub const icalrecurrencetype_weekday_ICAL_TUESDAY_WEEKDAY: icalrecurrencetype_weekday = 3;
pub const icalrecurrencetype_weekday_ICAL_WEDNESDAY_WEEKDAY: icalrecurrencetype_weekday = 4;
pub const icalrecurrencetype_weekday_ICAL_THURSDAY_WEEKDAY: icalrecurrencetype_weekday = 5;
pub const icalrecurrencetype_weekday_ICAL_FRIDAY_WEEKDAY: icalrecurrencetype_weekday = 6;
pub const icalrecurrencetype_weekday_ICAL_SATURDAY_WEEKDAY: icalrecurrencetype_weekday = 7;
pub type icalrecurrencetype_weekday = u32;
pub const icalrecurrencetype_skip_ICAL_SKIP_BACKWARD: icalrecurrencetype_skip = 0;
pub const icalrecurrencetype_skip_ICAL_SKIP_FORWARD: icalrecurrencetype_skip = 1;
pub const icalrecurrencetype_skip_ICAL_SKIP_OMIT: icalrecurrencetype_skip = 2;
pub const icalrecurrencetype_skip_ICAL_SKIP_UNDEFINED: icalrecurrencetype_skip = 3;
pub type icalrecurrencetype_skip = u32;
pub const icalrecurrence_array_max_values_ICAL_RECURRENCE_ARRAY_MAX:
    icalrecurrence_array_max_values = 32639;
pub const icalrecurrence_array_max_values_ICAL_RECURRENCE_ARRAY_MAX_BYTE:
    icalrecurrence_array_max_values = 127;
pub type icalrecurrence_array_max_values = u32;
extern "C" {
    pub fn icalrecur_string_to_freq(
        str: *const ::std::os::raw::c_char,
    ) -> icalrecurrencetype_frequency;
}
extern "C" {
    pub fn icalrecur_freq_to_string(
        kind: icalrecurrencetype_frequency,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalrecur_string_to_skip(str: *const ::std::os::raw::c_char) -> icalrecurrencetype_skip;
}
extern "C" {
    pub fn icalrecur_skip_to_string(kind: icalrecurrencetype_skip)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalrecur_weekday_to_string(
        kind: icalrecurrencetype_weekday,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalrecur_string_to_weekday(
        str: *const ::std::os::raw::c_char,
    ) -> icalrecurrencetype_weekday;
}
/// Main struct for holding digested recurrence rules
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icalrecurrencetype {
    pub freq: icalrecurrencetype_frequency,
    pub until: icaltimetype,
    pub count: ::std::os::raw::c_int,
    pub interval: ::std::os::raw::c_short,
    pub week_start: icalrecurrencetype_weekday,
    pub by_second: [::std::os::raw::c_short; 62usize],
    pub by_minute: [::std::os::raw::c_short; 61usize],
    pub by_hour: [::std::os::raw::c_short; 25usize],
    pub by_day: [::std::os::raw::c_short; 386usize],
    pub by_month_day: [::std::os::raw::c_short; 32usize],
    pub by_year_day: [::std::os::raw::c_short; 386usize],
    pub by_week_no: [::std::os::raw::c_short; 56usize],
    pub by_month: [::std::os::raw::c_short; 14usize],
    pub by_set_pos: [::std::os::raw::c_short; 386usize],
    pub rscale: *mut ::std::os::raw::c_char,
    pub skip: icalrecurrencetype_skip,
}
#[test]
fn bindgen_test_layout_icalrecurrencetype() {
    assert_eq!(
        ::std::mem::size_of::<icalrecurrencetype>(),
        2896usize,
        concat!("Size of: ", stringify!(icalrecurrencetype))
    );
    assert_eq!(
        ::std::mem::align_of::<icalrecurrencetype>(),
        8usize,
        concat!("Alignment of ", stringify!(icalrecurrencetype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).until as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(until)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).interval as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).week_start as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(week_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_second as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_second)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_minute as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_hour as *const _ as usize },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_day as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_month_day as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_month_day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_year_day as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_year_day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_week_no as *const _ as usize },
        1964usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_week_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_month as *const _ as usize },
        2076usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).by_set_pos as *const _ as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(by_set_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).rscale as *const _ as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(rscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalrecurrencetype>())).skip as *const _ as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(icalrecurrencetype),
            "::",
            stringify!(skip)
        )
    );
}
extern "C" {
    pub fn icalrecurrencetype_rscale_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalrecurrencetype_rscale_supported_calendars() -> *mut icalarray;
}
extern "C" {
    pub fn icalrecurrencetype_clear(r: *mut icalrecurrencetype);
}
extern "C" {
    /// 1 == Monday, etc.
    pub fn icalrecurrencetype_day_day_of_week(
        day: ::std::os::raw::c_short,
    ) -> icalrecurrencetype_weekday;
}
extern "C" {
    /// 0 == any of day of week. 1 == first, 2 = second, -2 == second to last, etc
    pub fn icalrecurrencetype_day_position(day: ::std::os::raw::c_short) -> ::std::os::raw::c_int;
}
extern "C" {
    /// The 'month' element of the by_month array is encoded to allow
    /// representation of the "L" leap suffix (RFC 7529).
    /// These routines decode the month values.
    pub fn icalrecurrencetype_month_is_leap(
        month: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalrecurrencetype_month_month(month: ::std::os::raw::c_short) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convert between strings and recurrencetype structures.
    pub fn icalrecurrencetype_from_string(str: *const ::std::os::raw::c_char)
        -> icalrecurrencetype;
}
extern "C" {
    pub fn icalrecurrencetype_as_string(
        recur: *mut icalrecurrencetype,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalrecurrencetype_as_string_r(
        recur: *mut icalrecurrencetype,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalrecur_iterator_impl {
    _unused: [u8; 0],
}
/// Recurrence iteration routines
pub type icalrecur_iterator = icalrecur_iterator_impl;
extern "C" {
    /// Create a new recurrence rule iterator, starting at DTSTART
    pub fn icalrecur_iterator_new(
        rule: icalrecurrencetype,
        dtstart: icaltimetype,
    ) -> *mut icalrecur_iterator;
}
extern "C" {
    /// Sets the date-time at which the iterator will start,
    /// where @p start is a value between DTSTART and UNTIL.
    ///
    /// NOTE: CAN NOT be used with RRULEs that contain COUNT.
    /// @since 3.0
    pub fn icalrecur_iterator_set_start(
        impl_: *mut icalrecur_iterator,
        start: icaltimetype,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the next occurrence from an iterator
    pub fn icalrecur_iterator_next(arg1: *mut icalrecur_iterator) -> icaltimetype;
}
extern "C" {
    /// Free the iterator
    pub fn icalrecur_iterator_free(arg1: *mut icalrecur_iterator);
}
extern "C" {
    /// Fills array up with at most 'count' time_t values, each
    ///  representing an occurrence time in seconds past the POSIX epoch
    pub fn icalrecur_expand_recurrence(
        rule: *const ::std::os::raw::c_char,
        start: time_t,
        count: ::std::os::raw::c_int,
        array: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalattach_impl {
    _unused: [u8; 0],
}
/// @typedef icalattach
/// @brief An iCal attach object representing a link to a document object.
///
/// Represents an association with a document object. ::icalattach objects
/// are reference counted, meaning that if the last reference to them is
/// removed (with icalattach_unref()), they are destroyed.
pub type icalattach = icalattach_impl;
/// @typedef icalattach_free_fn_t
/// @brief (*unused*) Function to be called to free the data of an ::icalattach object.
/// @warning Currently not used
///
/// This function type is used to free the data from an ::icalattach object created
/// with icalattach_new_from_data(). It is currently not used
pub type icalattach_free_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_uchar,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// @brief Create new ::icalattach object from a URL.
    /// @param url The URL to create the object from
    /// @return An ::icalattach object with the given URL as association
    /// @sa icalattach_unref()
    ///
    /// @par Error handling
    /// If @a url is `NULL`, it returns `NULL` and sets ::icalerrno to
    /// ::ICAL_BADARG_ERROR. If there was an error allocating memory, it
    /// returns `NULL` and sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The returned ::icalattach object is owned by the caller of the function.
    /// ::icalattach objects are reference counted, which means that after
    /// use, icalattach_unref() needs to be called to signal that they are
    /// not used anymore.
    ///
    /// ### Usage
    /// ```c
    /// // creates new
    /// icalattach *attach = icalattach_new_from_url("http://example.com");
    ///
    /// // checks it
    /// assert(icalattach_get_is_url(attach));
    /// assert(0 == strcmp(icalattach_get_url(attach), "http://example.com"));
    ///
    /// // release it
    /// icalattach_unref(attach);
    /// ```
    pub fn icalattach_new_from_url(url: *const ::std::os::raw::c_char) -> *mut icalattach;
}
extern "C" {
    /// @brief Create new ::icalattach object from data.
    /// @param data The data to create the ::icalattach from
    /// @param free_fn (*unused*) The function to free the data
    /// @param free_fn_data (*unused*) Data to pass to the @a free_fn
    /// @return An ::icalattach object with the given data
    /// @sa icalattach_unref()
    ///
    /// @par Error handling
    /// If @a url is `NULL`, it returns `NULL` and sets ::icalerrno to
    /// ::ICAL_BADARG_ERROR. If there was an error allocating memory, it
    /// returns `NULL` and sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The returned ::icalattach object is owned by the caller of the function.
    /// ::icalattach objects are reference counted, which means that after
    /// use, icalattach_unref() needs to be called to signal that they are
    /// not used anymore.
    pub fn icalattach_new_from_data(
        data: *const ::std::os::raw::c_char,
        free_fn: icalattach_free_fn_t,
        free_fn_data: *mut ::std::os::raw::c_void,
    ) -> *mut icalattach;
}
extern "C" {
    /// @brief Increments reference count of the ::icalattach.
    /// @param attach The object to increase the reference count of
    /// @sa icalattach_unref()
    ///
    /// @par Error handling
    /// If @a attach is `NULL`, or the reference count is smaller than 0,
    /// it sets ::icalerrno to ::ICAL_BADARG_ERROR.
    ///
    /// @par Ownership
    /// By increasing the refcount of @a attach, you are signaling that
    /// you are using it, and it is the owner's responsibility to call
    /// icalattach_unref() after it's no longer used.
    pub fn icalattach_ref(attach: *mut icalattach);
}
extern "C" {
    /// @brief Decrements reference count of the ::icalattach.
    /// @param attach The object to decrease the reference count of
    /// @sa icalattach_ref()
    ///
    /// Decreases the reference count of @a attach. If this was the
    /// last user of the object, it is freed.
    ///
    /// @par Error handling
    /// If @a attach is `NULL`, or the reference count is smaller than 0,
    /// it sets ::icalerrno to ::ICAL_BADARG_ERROR.
    ///
    /// @par Ownership
    /// Calling this function releases the icalattach back to the library,
    /// and it must not be used afterwards.
    ///
    /// ### Usage
    /// ```c
    /// // creates new
    /// icalattach *attach = icalattach_new_from_url("http://example.com");
    ///
    /// // release it
    /// icalattach_unref(attach);
    /// ```
    pub fn icalattach_unref(attach: *mut icalattach);
}
extern "C" {
    /// @brief Determines if @a attach is an URL.
    /// @param attach the ::icalattach object to check
    /// @return 1 if it is a URL, otherwise 0.
    /// @sa icalattach_get_url()
    ///
    /// @par Error handling
    /// Returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR if
    /// @a attach is `NULL`.
    ///
    /// ### Usage
    /// ```c
    /// // creates new
    /// icalattach *attach = icalattach_new_from_url("http://example.com");
    ///
    /// // checks if it is a URL
    /// assert(icalattach_get_is_url(attach));
    ///
    /// // release it
    /// icalattach_unref(attach);
    /// ```
    pub fn icalattach_get_is_url(attach: *mut icalattach) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns the URL of the ::icalattach object.
    /// @param attach The object from which to return the URL
    /// @return The URL of the object
    /// @sa icalattach_get_is_url()
    ///
    /// Returns the URL of the ::icalattach object.
    ///
    /// @par Error handling
    /// Returns `NULL` and set ::icalerrno to ::ICAL_BADARG_ERROR if
    /// @a attach is `NULL`. Undefined behaviour if the object is not
    /// a URL (check with icalattach_get_is_url()).
    ///
    /// @par Ownership
    /// The string returned is owned by libical and must not be freed
    /// by the caller.
    ///
    /// # Usage
    /// ```c
    /// // creates new
    /// icalattach *attach = icalattach_new_from_url("http://example.com");
    ///
    /// // checks it
    /// assert(icalattach_get_is_url(attach));
    /// assert(0 == strcmp(icalattach_get_url(attach), "http://example.com"));
    ///
    /// // release it
    /// icalattach_unref(attach);
    /// ```
    pub fn icalattach_get_url(attach: *mut icalattach) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Returns the data of the ::icalattach object.
    /// @param attach The object from which to return the data
    /// @return The data of the object
    /// @sa icalattach_get_is_url()
    ///
    /// Returns the URL of the ::icalattach object.
    ///
    /// @par Error handling
    /// Returns `NULL` and set ::icalerrno to ::ICAL_BADARG_ERROR if
    /// @a attach is `NULL`. Undefined behaviour if the object is
    /// a URL (check with icalattach_get_is_url()).
    ///
    /// @par Ownership
    /// The string returned is owned by libical and must not be freed
    /// by the caller.
    pub fn icalattach_get_data(attach: *mut icalattach) -> *mut ::std::os::raw::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalvalue_impl {
    _unused: [u8; 0],
}
pub type icalvalue = icalvalue_impl;
extern "C" {
    pub fn icalvalue_set_x(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_x(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_x(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_new_recur(v: icalrecurrencetype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_set_recur(value: *mut icalvalue, v: icalrecurrencetype);
}
extern "C" {
    pub fn icalvalue_get_recur(value: *const icalvalue) -> icalrecurrencetype;
}
extern "C" {
    pub fn icalvalue_new_trigger(v: icaltriggertype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_set_trigger(value: *mut icalvalue, v: icaltriggertype);
}
extern "C" {
    pub fn icalvalue_get_trigger(value: *const icalvalue) -> icaltriggertype;
}
extern "C" {
    pub fn icalvalue_new_date(v: icaltimetype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_date(value: *const icalvalue) -> icaltimetype;
}
extern "C" {
    pub fn icalvalue_set_date(value: *mut icalvalue, v: icaltimetype);
}
extern "C" {
    /// Creates a new icalvalue representing the specified icaltimetype.
    /// @param v is an @p icaltimetype
    /// @since 3.0
    pub fn icalvalue_new_datetime(v: icaltimetype) -> *mut icalvalue;
}
extern "C" {
    /// Returns the icaltimetype corresponding to the specified icalvalue.
    /// @param a pointer to an icalvalue.
    /// @returns the icaltimetype as datetime.
    /// @since 3.0
    pub fn icalvalue_get_datetime(value: *const icalvalue) -> icaltimetype;
}
extern "C" {
    /// Sets an icalvalue for the specified icaltimetype.
    /// @param value is a pointer to an icalvalue.
    /// @param v is
    /// @since 3.0
    pub fn icalvalue_set_datetime(value: *mut icalvalue, v: icaltimetype);
}
extern "C" {
    pub fn icalvalue_new_datetimedate(v: icaltimetype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_datetimedate(value: *const icalvalue) -> icaltimetype;
}
extern "C" {
    pub fn icalvalue_set_datetimedate(value: *mut icalvalue, v: icaltimetype);
}
extern "C" {
    pub fn icalvalue_new_datetimeperiod(v: icaldatetimeperiodtype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_set_datetimeperiod(value: *mut icalvalue, v: icaldatetimeperiodtype);
}
extern "C" {
    pub fn icalvalue_get_datetimeperiod(value: *const icalvalue) -> icaldatetimeperiodtype;
}
extern "C" {
    pub fn icalvalue_new_geo(v: icalgeotype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_geo(value: *const icalvalue) -> icalgeotype;
}
extern "C" {
    pub fn icalvalue_set_geo(value: *mut icalvalue, v: icalgeotype);
}
extern "C" {
    pub fn icalvalue_new_attach(attach: *mut icalattach) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_set_attach(value: *mut icalvalue, attach: *mut icalattach);
}
extern "C" {
    pub fn icalvalue_get_attach(value: *const icalvalue) -> *mut icalattach;
}
extern "C" {
    pub fn icalvalue_new_binary(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_set_binary(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_get_binary(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_reset_kind(value: *mut icalvalue);
}
pub const icalvalue_kind_ICAL_ANY_VALUE: icalvalue_kind = 5000;
pub const icalvalue_kind_ICAL_ACTION_VALUE: icalvalue_kind = 5027;
pub const icalvalue_kind_ICAL_ATTACH_VALUE: icalvalue_kind = 5003;
pub const icalvalue_kind_ICAL_BINARY_VALUE: icalvalue_kind = 5011;
pub const icalvalue_kind_ICAL_BOOLEAN_VALUE: icalvalue_kind = 5021;
pub const icalvalue_kind_ICAL_BUSYTYPE_VALUE: icalvalue_kind = 5032;
pub const icalvalue_kind_ICAL_CALADDRESS_VALUE: icalvalue_kind = 5023;
pub const icalvalue_kind_ICAL_CARLEVEL_VALUE: icalvalue_kind = 5016;
pub const icalvalue_kind_ICAL_CLASS_VALUE: icalvalue_kind = 5019;
pub const icalvalue_kind_ICAL_CMD_VALUE: icalvalue_kind = 5010;
pub const icalvalue_kind_ICAL_DATE_VALUE: icalvalue_kind = 5002;
pub const icalvalue_kind_ICAL_DATETIME_VALUE: icalvalue_kind = 5028;
pub const icalvalue_kind_ICAL_DATETIMEDATE_VALUE: icalvalue_kind = 5036;
pub const icalvalue_kind_ICAL_DATETIMEPERIOD_VALUE: icalvalue_kind = 5015;
pub const icalvalue_kind_ICAL_DURATION_VALUE: icalvalue_kind = 5020;
pub const icalvalue_kind_ICAL_FLOAT_VALUE: icalvalue_kind = 5013;
pub const icalvalue_kind_ICAL_GEO_VALUE: icalvalue_kind = 5004;
pub const icalvalue_kind_ICAL_INTEGER_VALUE: icalvalue_kind = 5017;
pub const icalvalue_kind_ICAL_METHOD_VALUE: icalvalue_kind = 5030;
pub const icalvalue_kind_ICAL_PERIOD_VALUE: icalvalue_kind = 5014;
pub const icalvalue_kind_ICAL_POLLCOMPLETION_VALUE: icalvalue_kind = 5034;
pub const icalvalue_kind_ICAL_POLLMODE_VALUE: icalvalue_kind = 5033;
pub const icalvalue_kind_ICAL_QUERY_VALUE: icalvalue_kind = 5001;
pub const icalvalue_kind_ICAL_QUERYLEVEL_VALUE: icalvalue_kind = 5012;
pub const icalvalue_kind_ICAL_RECUR_VALUE: icalvalue_kind = 5026;
pub const icalvalue_kind_ICAL_REQUESTSTATUS_VALUE: icalvalue_kind = 5009;
pub const icalvalue_kind_ICAL_STATUS_VALUE: icalvalue_kind = 5005;
pub const icalvalue_kind_ICAL_STRING_VALUE: icalvalue_kind = 5007;
pub const icalvalue_kind_ICAL_TASKMODE_VALUE: icalvalue_kind = 5035;
pub const icalvalue_kind_ICAL_TEXT_VALUE: icalvalue_kind = 5008;
pub const icalvalue_kind_ICAL_TRANSP_VALUE: icalvalue_kind = 5006;
pub const icalvalue_kind_ICAL_TRIGGER_VALUE: icalvalue_kind = 5024;
pub const icalvalue_kind_ICAL_URI_VALUE: icalvalue_kind = 5018;
pub const icalvalue_kind_ICAL_UTCOFFSET_VALUE: icalvalue_kind = 5029;
pub const icalvalue_kind_ICAL_X_VALUE: icalvalue_kind = 5022;
pub const icalvalue_kind_ICAL_XLICCLASS_VALUE: icalvalue_kind = 5025;
pub const icalvalue_kind_ICAL_NO_VALUE: icalvalue_kind = 5031;
pub type icalvalue_kind = u32;
pub const icalproperty_action_ICAL_ACTION_X: icalproperty_action = 10000;
pub const icalproperty_action_ICAL_ACTION_AUDIO: icalproperty_action = 10001;
pub const icalproperty_action_ICAL_ACTION_DISPLAY: icalproperty_action = 10002;
pub const icalproperty_action_ICAL_ACTION_EMAIL: icalproperty_action = 10003;
pub const icalproperty_action_ICAL_ACTION_PROCEDURE: icalproperty_action = 10004;
pub const icalproperty_action_ICAL_ACTION_NONE: icalproperty_action = 10099;
pub type icalproperty_action = u32;
pub const icalproperty_busytype_ICAL_BUSYTYPE_X: icalproperty_busytype = 10100;
pub const icalproperty_busytype_ICAL_BUSYTYPE_BUSY: icalproperty_busytype = 10101;
pub const icalproperty_busytype_ICAL_BUSYTYPE_BUSYUNAVAILABLE: icalproperty_busytype = 10102;
pub const icalproperty_busytype_ICAL_BUSYTYPE_BUSYTENTATIVE: icalproperty_busytype = 10103;
pub const icalproperty_busytype_ICAL_BUSYTYPE_NONE: icalproperty_busytype = 10199;
pub type icalproperty_busytype = u32;
pub const icalproperty_carlevel_ICAL_CARLEVEL_X: icalproperty_carlevel = 10200;
pub const icalproperty_carlevel_ICAL_CARLEVEL_CARNONE: icalproperty_carlevel = 10201;
pub const icalproperty_carlevel_ICAL_CARLEVEL_CARMIN: icalproperty_carlevel = 10202;
pub const icalproperty_carlevel_ICAL_CARLEVEL_CARFULL1: icalproperty_carlevel = 10203;
pub const icalproperty_carlevel_ICAL_CARLEVEL_NONE: icalproperty_carlevel = 10299;
pub type icalproperty_carlevel = u32;
pub const icalproperty_class_ICAL_CLASS_X: icalproperty_class = 10300;
pub const icalproperty_class_ICAL_CLASS_PUBLIC: icalproperty_class = 10301;
pub const icalproperty_class_ICAL_CLASS_PRIVATE: icalproperty_class = 10302;
pub const icalproperty_class_ICAL_CLASS_CONFIDENTIAL: icalproperty_class = 10303;
pub const icalproperty_class_ICAL_CLASS_NONE: icalproperty_class = 10399;
pub type icalproperty_class = u32;
pub const icalproperty_cmd_ICAL_CMD_X: icalproperty_cmd = 10400;
pub const icalproperty_cmd_ICAL_CMD_ABORT: icalproperty_cmd = 10401;
pub const icalproperty_cmd_ICAL_CMD_CONTINUE: icalproperty_cmd = 10402;
pub const icalproperty_cmd_ICAL_CMD_CREATE: icalproperty_cmd = 10403;
pub const icalproperty_cmd_ICAL_CMD_DELETE: icalproperty_cmd = 10404;
pub const icalproperty_cmd_ICAL_CMD_GENERATEUID: icalproperty_cmd = 10405;
pub const icalproperty_cmd_ICAL_CMD_GETCAPABILITY: icalproperty_cmd = 10406;
pub const icalproperty_cmd_ICAL_CMD_IDENTIFY: icalproperty_cmd = 10407;
pub const icalproperty_cmd_ICAL_CMD_MODIFY: icalproperty_cmd = 10408;
pub const icalproperty_cmd_ICAL_CMD_MOVE: icalproperty_cmd = 10409;
pub const icalproperty_cmd_ICAL_CMD_REPLY: icalproperty_cmd = 10410;
pub const icalproperty_cmd_ICAL_CMD_SEARCH: icalproperty_cmd = 10411;
pub const icalproperty_cmd_ICAL_CMD_SETLOCALE: icalproperty_cmd = 10412;
pub const icalproperty_cmd_ICAL_CMD_NONE: icalproperty_cmd = 10499;
pub type icalproperty_cmd = u32;
pub const icalproperty_method_ICAL_METHOD_X: icalproperty_method = 10500;
pub const icalproperty_method_ICAL_METHOD_PUBLISH: icalproperty_method = 10501;
pub const icalproperty_method_ICAL_METHOD_REQUEST: icalproperty_method = 10502;
pub const icalproperty_method_ICAL_METHOD_REPLY: icalproperty_method = 10503;
pub const icalproperty_method_ICAL_METHOD_ADD: icalproperty_method = 10504;
pub const icalproperty_method_ICAL_METHOD_CANCEL: icalproperty_method = 10505;
pub const icalproperty_method_ICAL_METHOD_REFRESH: icalproperty_method = 10506;
pub const icalproperty_method_ICAL_METHOD_COUNTER: icalproperty_method = 10507;
pub const icalproperty_method_ICAL_METHOD_DECLINECOUNTER: icalproperty_method = 10508;
pub const icalproperty_method_ICAL_METHOD_CREATE: icalproperty_method = 10509;
pub const icalproperty_method_ICAL_METHOD_READ: icalproperty_method = 10510;
pub const icalproperty_method_ICAL_METHOD_RESPONSE: icalproperty_method = 10511;
pub const icalproperty_method_ICAL_METHOD_MOVE: icalproperty_method = 10512;
pub const icalproperty_method_ICAL_METHOD_MODIFY: icalproperty_method = 10513;
pub const icalproperty_method_ICAL_METHOD_GENERATEUID: icalproperty_method = 10514;
pub const icalproperty_method_ICAL_METHOD_DELETE: icalproperty_method = 10515;
pub const icalproperty_method_ICAL_METHOD_POLLSTATUS: icalproperty_method = 10516;
pub const icalproperty_method_ICAL_METHOD_NONE: icalproperty_method = 10599;
pub type icalproperty_method = u32;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_X: icalproperty_pollcompletion = 10600;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_SERVER: icalproperty_pollcompletion =
    10601;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_SERVERSUBMIT:
    icalproperty_pollcompletion = 10602;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_SERVERCHOICE:
    icalproperty_pollcompletion = 10603;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_CLIENT: icalproperty_pollcompletion =
    10604;
pub const icalproperty_pollcompletion_ICAL_POLLCOMPLETION_NONE: icalproperty_pollcompletion = 10699;
pub type icalproperty_pollcompletion = u32;
pub const icalproperty_pollmode_ICAL_POLLMODE_X: icalproperty_pollmode = 10700;
pub const icalproperty_pollmode_ICAL_POLLMODE_BASIC: icalproperty_pollmode = 10701;
pub const icalproperty_pollmode_ICAL_POLLMODE_NONE: icalproperty_pollmode = 10799;
pub type icalproperty_pollmode = u32;
pub const icalproperty_querylevel_ICAL_QUERYLEVEL_X: icalproperty_querylevel = 10800;
pub const icalproperty_querylevel_ICAL_QUERYLEVEL_CALQL1: icalproperty_querylevel = 10801;
pub const icalproperty_querylevel_ICAL_QUERYLEVEL_CALQLNONE: icalproperty_querylevel = 10802;
pub const icalproperty_querylevel_ICAL_QUERYLEVEL_NONE: icalproperty_querylevel = 10899;
pub type icalproperty_querylevel = u32;
pub const icalproperty_status_ICAL_STATUS_X: icalproperty_status = 10900;
pub const icalproperty_status_ICAL_STATUS_TENTATIVE: icalproperty_status = 10901;
pub const icalproperty_status_ICAL_STATUS_CONFIRMED: icalproperty_status = 10902;
pub const icalproperty_status_ICAL_STATUS_COMPLETED: icalproperty_status = 10903;
pub const icalproperty_status_ICAL_STATUS_NEEDSACTION: icalproperty_status = 10904;
pub const icalproperty_status_ICAL_STATUS_CANCELLED: icalproperty_status = 10905;
pub const icalproperty_status_ICAL_STATUS_INPROCESS: icalproperty_status = 10906;
pub const icalproperty_status_ICAL_STATUS_DRAFT: icalproperty_status = 10907;
pub const icalproperty_status_ICAL_STATUS_FINAL: icalproperty_status = 10908;
pub const icalproperty_status_ICAL_STATUS_SUBMITTED: icalproperty_status = 10909;
pub const icalproperty_status_ICAL_STATUS_PENDING: icalproperty_status = 10910;
pub const icalproperty_status_ICAL_STATUS_FAILED: icalproperty_status = 10911;
pub const icalproperty_status_ICAL_STATUS_DELETED: icalproperty_status = 10912;
pub const icalproperty_status_ICAL_STATUS_NONE: icalproperty_status = 10999;
pub type icalproperty_status = u32;
pub const icalproperty_taskmode_ICAL_TASKMODE_X: icalproperty_taskmode = 11200;
pub const icalproperty_taskmode_ICAL_TASKMODE_AUTOMATICCOMPLETION: icalproperty_taskmode = 11201;
pub const icalproperty_taskmode_ICAL_TASKMODE_AUTOMATICFAILURE: icalproperty_taskmode = 11202;
pub const icalproperty_taskmode_ICAL_TASKMODE_AUTOMATICSTATUS: icalproperty_taskmode = 11203;
pub const icalproperty_taskmode_ICAL_TASKMODE_NONE: icalproperty_taskmode = 11299;
pub type icalproperty_taskmode = u32;
pub const icalproperty_transp_ICAL_TRANSP_X: icalproperty_transp = 11000;
pub const icalproperty_transp_ICAL_TRANSP_OPAQUE: icalproperty_transp = 11001;
pub const icalproperty_transp_ICAL_TRANSP_OPAQUENOCONFLICT: icalproperty_transp = 11002;
pub const icalproperty_transp_ICAL_TRANSP_TRANSPARENT: icalproperty_transp = 11003;
pub const icalproperty_transp_ICAL_TRANSP_TRANSPARENTNOCONFLICT: icalproperty_transp = 11004;
pub const icalproperty_transp_ICAL_TRANSP_NONE: icalproperty_transp = 11099;
pub type icalproperty_transp = u32;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_X: icalproperty_xlicclass = 11100;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_PUBLISHNEW: icalproperty_xlicclass = 11101;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_PUBLISHUPDATE: icalproperty_xlicclass = 11102;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_PUBLISHFREEBUSY: icalproperty_xlicclass = 11103;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTNEW: icalproperty_xlicclass = 11104;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTUPDATE: icalproperty_xlicclass = 11105;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTRESCHEDULE: icalproperty_xlicclass = 11106;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTDELEGATE: icalproperty_xlicclass = 11107;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTNEWORGANIZER: icalproperty_xlicclass = 11108;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTFORWARD: icalproperty_xlicclass = 11109;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTSTATUS: icalproperty_xlicclass = 11110;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REQUESTFREEBUSY: icalproperty_xlicclass = 11111;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REPLYACCEPT: icalproperty_xlicclass = 11112;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REPLYDECLINE: icalproperty_xlicclass = 11113;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REPLYDELEGATE: icalproperty_xlicclass = 11114;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REPLYCRASHERACCEPT: icalproperty_xlicclass = 11115;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REPLYCRASHERDECLINE: icalproperty_xlicclass = 11116;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_ADDINSTANCE: icalproperty_xlicclass = 11117;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_CANCELEVENT: icalproperty_xlicclass = 11118;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_CANCELINSTANCE: icalproperty_xlicclass = 11119;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_CANCELALL: icalproperty_xlicclass = 11120;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_REFRESH: icalproperty_xlicclass = 11121;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_COUNTER: icalproperty_xlicclass = 11122;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_DECLINECOUNTER: icalproperty_xlicclass = 11123;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_MALFORMED: icalproperty_xlicclass = 11124;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_OBSOLETE: icalproperty_xlicclass = 11125;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_MISSEQUENCED: icalproperty_xlicclass = 11126;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_UNKNOWN: icalproperty_xlicclass = 11127;
pub const icalproperty_xlicclass_ICAL_XLICCLASS_NONE: icalproperty_xlicclass = 11199;
pub type icalproperty_xlicclass = u32;
extern "C" {
    pub fn icalvalue_new_action(v: icalproperty_action) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_action(value: *const icalvalue) -> icalproperty_action;
}
extern "C" {
    pub fn icalvalue_set_action(value: *mut icalvalue, v: icalproperty_action);
}
extern "C" {
    pub fn icalvalue_new_boolean(v: ::std::os::raw::c_int) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_boolean(value: *const icalvalue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalvalue_set_boolean(value: *mut icalvalue, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalvalue_new_busytype(v: icalproperty_busytype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_busytype(value: *const icalvalue) -> icalproperty_busytype;
}
extern "C" {
    pub fn icalvalue_set_busytype(value: *mut icalvalue, v: icalproperty_busytype);
}
extern "C" {
    pub fn icalvalue_new_caladdress(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_caladdress(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_set_caladdress(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_carlevel(v: icalproperty_carlevel) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_carlevel(value: *const icalvalue) -> icalproperty_carlevel;
}
extern "C" {
    pub fn icalvalue_set_carlevel(value: *mut icalvalue, v: icalproperty_carlevel);
}
extern "C" {
    pub fn icalvalue_new_cmd(v: icalproperty_cmd) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_cmd(value: *const icalvalue) -> icalproperty_cmd;
}
extern "C" {
    pub fn icalvalue_set_cmd(value: *mut icalvalue, v: icalproperty_cmd);
}
extern "C" {
    pub fn icalvalue_new_duration(v: icaldurationtype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_duration(value: *const icalvalue) -> icaldurationtype;
}
extern "C" {
    pub fn icalvalue_set_duration(value: *mut icalvalue, v: icaldurationtype);
}
extern "C" {
    pub fn icalvalue_new_float(v: f32) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_float(value: *const icalvalue) -> f32;
}
extern "C" {
    pub fn icalvalue_set_float(value: *mut icalvalue, v: f32);
}
extern "C" {
    pub fn icalvalue_new_integer(v: ::std::os::raw::c_int) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_integer(value: *const icalvalue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalvalue_set_integer(value: *mut icalvalue, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalvalue_new_method(v: icalproperty_method) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_method(value: *const icalvalue) -> icalproperty_method;
}
extern "C" {
    pub fn icalvalue_set_method(value: *mut icalvalue, v: icalproperty_method);
}
extern "C" {
    pub fn icalvalue_new_period(v: icalperiodtype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_period(value: *const icalvalue) -> icalperiodtype;
}
extern "C" {
    pub fn icalvalue_set_period(value: *mut icalvalue, v: icalperiodtype);
}
extern "C" {
    pub fn icalvalue_new_pollcompletion(v: icalproperty_pollcompletion) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_pollcompletion(value: *const icalvalue) -> icalproperty_pollcompletion;
}
extern "C" {
    pub fn icalvalue_set_pollcompletion(value: *mut icalvalue, v: icalproperty_pollcompletion);
}
extern "C" {
    pub fn icalvalue_new_pollmode(v: icalproperty_pollmode) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_pollmode(value: *const icalvalue) -> icalproperty_pollmode;
}
extern "C" {
    pub fn icalvalue_set_pollmode(value: *mut icalvalue, v: icalproperty_pollmode);
}
extern "C" {
    pub fn icalvalue_new_query(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_query(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_set_query(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_querylevel(v: icalproperty_querylevel) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_querylevel(value: *const icalvalue) -> icalproperty_querylevel;
}
extern "C" {
    pub fn icalvalue_set_querylevel(value: *mut icalvalue, v: icalproperty_querylevel);
}
extern "C" {
    pub fn icalvalue_new_requeststatus(v: icalreqstattype) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_requeststatus(value: *const icalvalue) -> icalreqstattype;
}
extern "C" {
    pub fn icalvalue_set_requeststatus(value: *mut icalvalue, v: icalreqstattype);
}
extern "C" {
    pub fn icalvalue_new_status(v: icalproperty_status) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_status(value: *const icalvalue) -> icalproperty_status;
}
extern "C" {
    pub fn icalvalue_set_status(value: *mut icalvalue, v: icalproperty_status);
}
extern "C" {
    pub fn icalvalue_new_string(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_string(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_set_string(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_taskmode(v: icalproperty_taskmode) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_taskmode(value: *const icalvalue) -> icalproperty_taskmode;
}
extern "C" {
    pub fn icalvalue_set_taskmode(value: *mut icalvalue, v: icalproperty_taskmode);
}
extern "C" {
    pub fn icalvalue_new_text(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_text(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_set_text(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_transp(v: icalproperty_transp) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_transp(value: *const icalvalue) -> icalproperty_transp;
}
extern "C" {
    pub fn icalvalue_set_transp(value: *mut icalvalue, v: icalproperty_transp);
}
extern "C" {
    pub fn icalvalue_new_uri(v: *const ::std::os::raw::c_char) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_uri(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_set_uri(value: *mut icalvalue, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalvalue_new_utcoffset(v: ::std::os::raw::c_int) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_utcoffset(value: *const icalvalue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalvalue_set_utcoffset(value: *mut icalvalue, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalvalue_new_xlicclass(v: icalproperty_xlicclass) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_xlicclass(value: *const icalvalue) -> icalproperty_xlicclass;
}
extern "C" {
    pub fn icalvalue_set_xlicclass(value: *mut icalvalue, v: icalproperty_xlicclass);
}
extern "C" {
    pub fn icalvalue_new_class(v: icalproperty_class) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_get_class(value: *const icalvalue) -> icalproperty_class;
}
extern "C" {
    pub fn icalvalue_set_class(value: *mut icalvalue, v: icalproperty_class);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalparameter_impl {
    _unused: [u8; 0],
}
pub type icalparameter = icalparameter_impl;
extern "C" {
    pub fn icalparameter_enum_to_string(e: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_string_to_enum(
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const icalparameter_kind_ICAL_ANY_PARAMETER: icalparameter_kind = 0;
pub const icalparameter_kind_ICAL_ACTIONPARAM_PARAMETER: icalparameter_kind = 1;
pub const icalparameter_kind_ICAL_ALTREP_PARAMETER: icalparameter_kind = 2;
pub const icalparameter_kind_ICAL_CHARSET_PARAMETER: icalparameter_kind = 3;
pub const icalparameter_kind_ICAL_CN_PARAMETER: icalparameter_kind = 4;
pub const icalparameter_kind_ICAL_CUTYPE_PARAMETER: icalparameter_kind = 5;
pub const icalparameter_kind_ICAL_DELEGATEDFROM_PARAMETER: icalparameter_kind = 6;
pub const icalparameter_kind_ICAL_DELEGATEDTO_PARAMETER: icalparameter_kind = 7;
pub const icalparameter_kind_ICAL_DIR_PARAMETER: icalparameter_kind = 8;
pub const icalparameter_kind_ICAL_DISPLAY_PARAMETER: icalparameter_kind = 46;
pub const icalparameter_kind_ICAL_EMAIL_PARAMETER: icalparameter_kind = 50;
pub const icalparameter_kind_ICAL_ENABLE_PARAMETER: icalparameter_kind = 9;
pub const icalparameter_kind_ICAL_ENCODING_PARAMETER: icalparameter_kind = 10;
pub const icalparameter_kind_ICAL_FBTYPE_PARAMETER: icalparameter_kind = 11;
pub const icalparameter_kind_ICAL_FEATURE_PARAMETER: icalparameter_kind = 48;
pub const icalparameter_kind_ICAL_FILENAME_PARAMETER: icalparameter_kind = 42;
pub const icalparameter_kind_ICAL_FMTTYPE_PARAMETER: icalparameter_kind = 12;
pub const icalparameter_kind_ICAL_IANA_PARAMETER: icalparameter_kind = 33;
pub const icalparameter_kind_ICAL_ID_PARAMETER: icalparameter_kind = 13;
pub const icalparameter_kind_ICAL_LABEL_PARAMETER: icalparameter_kind = 49;
pub const icalparameter_kind_ICAL_LANGUAGE_PARAMETER: icalparameter_kind = 14;
pub const icalparameter_kind_ICAL_LATENCY_PARAMETER: icalparameter_kind = 15;
pub const icalparameter_kind_ICAL_LOCAL_PARAMETER: icalparameter_kind = 16;
pub const icalparameter_kind_ICAL_LOCALIZE_PARAMETER: icalparameter_kind = 17;
pub const icalparameter_kind_ICAL_MANAGEDID_PARAMETER: icalparameter_kind = 40;
pub const icalparameter_kind_ICAL_MEMBER_PARAMETER: icalparameter_kind = 18;
pub const icalparameter_kind_ICAL_MODIFIED_PARAMETER: icalparameter_kind = 44;
pub const icalparameter_kind_ICAL_OPTIONS_PARAMETER: icalparameter_kind = 19;
pub const icalparameter_kind_ICAL_PARTSTAT_PARAMETER: icalparameter_kind = 20;
pub const icalparameter_kind_ICAL_PATCHACTION_PARAMETER: icalparameter_kind = 51;
pub const icalparameter_kind_ICAL_PUBLICCOMMENT_PARAMETER: icalparameter_kind = 37;
pub const icalparameter_kind_ICAL_RANGE_PARAMETER: icalparameter_kind = 21;
pub const icalparameter_kind_ICAL_REASON_PARAMETER: icalparameter_kind = 43;
pub const icalparameter_kind_ICAL_RELATED_PARAMETER: icalparameter_kind = 22;
pub const icalparameter_kind_ICAL_RELTYPE_PARAMETER: icalparameter_kind = 23;
pub const icalparameter_kind_ICAL_REQUIRED_PARAMETER: icalparameter_kind = 43;
pub const icalparameter_kind_ICAL_RESPONSE_PARAMETER: icalparameter_kind = 38;
pub const icalparameter_kind_ICAL_ROLE_PARAMETER: icalparameter_kind = 24;
pub const icalparameter_kind_ICAL_RSVP_PARAMETER: icalparameter_kind = 25;
pub const icalparameter_kind_ICAL_SCHEDULEAGENT_PARAMETER: icalparameter_kind = 34;
pub const icalparameter_kind_ICAL_SCHEDULEFORCESEND_PARAMETER: icalparameter_kind = 35;
pub const icalparameter_kind_ICAL_SCHEDULESTATUS_PARAMETER: icalparameter_kind = 36;
pub const icalparameter_kind_ICAL_SENTBY_PARAMETER: icalparameter_kind = 26;
pub const icalparameter_kind_ICAL_SIZE_PARAMETER: icalparameter_kind = 41;
pub const icalparameter_kind_ICAL_STAYINFORMED_PARAMETER: icalparameter_kind = 39;
pub const icalparameter_kind_ICAL_SUBSTATE_PARAMETER: icalparameter_kind = 45;
pub const icalparameter_kind_ICAL_TZID_PARAMETER: icalparameter_kind = 27;
pub const icalparameter_kind_ICAL_VALUE_PARAMETER: icalparameter_kind = 28;
pub const icalparameter_kind_ICAL_X_PARAMETER: icalparameter_kind = 29;
pub const icalparameter_kind_ICAL_XLICCOMPARETYPE_PARAMETER: icalparameter_kind = 30;
pub const icalparameter_kind_ICAL_XLICERRORTYPE_PARAMETER: icalparameter_kind = 31;
pub const icalparameter_kind_ICAL_NO_PARAMETER: icalparameter_kind = 32;
pub type icalparameter_kind = u32;
pub const icalparameter_action_ICAL_ACTIONPARAM_X: icalparameter_action = 20000;
pub const icalparameter_action_ICAL_ACTIONPARAM_ASK: icalparameter_action = 20001;
pub const icalparameter_action_ICAL_ACTIONPARAM_ABORT: icalparameter_action = 20002;
pub const icalparameter_action_ICAL_ACTIONPARAM_NONE: icalparameter_action = 20099;
pub type icalparameter_action = u32;
pub const icalparameter_cutype_ICAL_CUTYPE_X: icalparameter_cutype = 20100;
pub const icalparameter_cutype_ICAL_CUTYPE_INDIVIDUAL: icalparameter_cutype = 20101;
pub const icalparameter_cutype_ICAL_CUTYPE_GROUP: icalparameter_cutype = 20102;
pub const icalparameter_cutype_ICAL_CUTYPE_RESOURCE: icalparameter_cutype = 20103;
pub const icalparameter_cutype_ICAL_CUTYPE_ROOM: icalparameter_cutype = 20104;
pub const icalparameter_cutype_ICAL_CUTYPE_UNKNOWN: icalparameter_cutype = 20105;
pub const icalparameter_cutype_ICAL_CUTYPE_NONE: icalparameter_cutype = 20199;
pub type icalparameter_cutype = u32;
pub const icalparameter_display_ICAL_DISPLAY_X: icalparameter_display = 22000;
pub const icalparameter_display_ICAL_DISPLAY_BADGE: icalparameter_display = 22001;
pub const icalparameter_display_ICAL_DISPLAY_GRAPHIC: icalparameter_display = 22002;
pub const icalparameter_display_ICAL_DISPLAY_FULLSIZE: icalparameter_display = 22003;
pub const icalparameter_display_ICAL_DISPLAY_THUMBNAIL: icalparameter_display = 22004;
pub const icalparameter_display_ICAL_DISPLAY_NONE: icalparameter_display = 22099;
pub type icalparameter_display = u32;
pub const icalparameter_enable_ICAL_ENABLE_X: icalparameter_enable = 20200;
pub const icalparameter_enable_ICAL_ENABLE_TRUE: icalparameter_enable = 20201;
pub const icalparameter_enable_ICAL_ENABLE_FALSE: icalparameter_enable = 20202;
pub const icalparameter_enable_ICAL_ENABLE_NONE: icalparameter_enable = 20299;
pub type icalparameter_enable = u32;
pub const icalparameter_encoding_ICAL_ENCODING_X: icalparameter_encoding = 20300;
pub const icalparameter_encoding_ICAL_ENCODING_8BIT: icalparameter_encoding = 20301;
pub const icalparameter_encoding_ICAL_ENCODING_BASE64: icalparameter_encoding = 20302;
pub const icalparameter_encoding_ICAL_ENCODING_NONE: icalparameter_encoding = 20399;
pub type icalparameter_encoding = u32;
pub const icalparameter_fbtype_ICAL_FBTYPE_X: icalparameter_fbtype = 20400;
pub const icalparameter_fbtype_ICAL_FBTYPE_FREE: icalparameter_fbtype = 20401;
pub const icalparameter_fbtype_ICAL_FBTYPE_BUSY: icalparameter_fbtype = 20402;
pub const icalparameter_fbtype_ICAL_FBTYPE_BUSYUNAVAILABLE: icalparameter_fbtype = 20403;
pub const icalparameter_fbtype_ICAL_FBTYPE_BUSYTENTATIVE: icalparameter_fbtype = 20404;
pub const icalparameter_fbtype_ICAL_FBTYPE_NONE: icalparameter_fbtype = 20499;
pub type icalparameter_fbtype = u32;
pub const icalparameter_feature_ICAL_FEATURE_X: icalparameter_feature = 22100;
pub const icalparameter_feature_ICAL_FEATURE_AUDIO: icalparameter_feature = 22101;
pub const icalparameter_feature_ICAL_FEATURE_CHAT: icalparameter_feature = 22102;
pub const icalparameter_feature_ICAL_FEATURE_FEED: icalparameter_feature = 22103;
pub const icalparameter_feature_ICAL_FEATURE_MODERATOR: icalparameter_feature = 22104;
pub const icalparameter_feature_ICAL_FEATURE_PHONE: icalparameter_feature = 22105;
pub const icalparameter_feature_ICAL_FEATURE_SCREEN: icalparameter_feature = 22106;
pub const icalparameter_feature_ICAL_FEATURE_VIDEO: icalparameter_feature = 22107;
pub const icalparameter_feature_ICAL_FEATURE_NONE: icalparameter_feature = 22199;
pub type icalparameter_feature = u32;
pub const icalparameter_local_ICAL_LOCAL_X: icalparameter_local = 20500;
pub const icalparameter_local_ICAL_LOCAL_TRUE: icalparameter_local = 20501;
pub const icalparameter_local_ICAL_LOCAL_FALSE: icalparameter_local = 20502;
pub const icalparameter_local_ICAL_LOCAL_NONE: icalparameter_local = 20599;
pub type icalparameter_local = u32;
pub const icalparameter_partstat_ICAL_PARTSTAT_X: icalparameter_partstat = 20600;
pub const icalparameter_partstat_ICAL_PARTSTAT_NEEDSACTION: icalparameter_partstat = 20601;
pub const icalparameter_partstat_ICAL_PARTSTAT_ACCEPTED: icalparameter_partstat = 20602;
pub const icalparameter_partstat_ICAL_PARTSTAT_DECLINED: icalparameter_partstat = 20603;
pub const icalparameter_partstat_ICAL_PARTSTAT_TENTATIVE: icalparameter_partstat = 20604;
pub const icalparameter_partstat_ICAL_PARTSTAT_DELEGATED: icalparameter_partstat = 20605;
pub const icalparameter_partstat_ICAL_PARTSTAT_COMPLETED: icalparameter_partstat = 20606;
pub const icalparameter_partstat_ICAL_PARTSTAT_INPROCESS: icalparameter_partstat = 20607;
pub const icalparameter_partstat_ICAL_PARTSTAT_FAILED: icalparameter_partstat = 20608;
pub const icalparameter_partstat_ICAL_PARTSTAT_NONE: icalparameter_partstat = 20699;
pub type icalparameter_partstat = u32;
pub const icalparameter_patchaction_ICAL_PATCHACTION_X: icalparameter_patchaction = 22200;
pub const icalparameter_patchaction_ICAL_PATCHACTION_CREATE: icalparameter_patchaction = 22201;
pub const icalparameter_patchaction_ICAL_PATCHACTION_BYNAME: icalparameter_patchaction = 22202;
pub const icalparameter_patchaction_ICAL_PATCHACTION_BYVALUE: icalparameter_patchaction = 22203;
pub const icalparameter_patchaction_ICAL_PATCHACTION_BYPARAM: icalparameter_patchaction = 22204;
pub const icalparameter_patchaction_ICAL_PATCHACTION_NONE: icalparameter_patchaction = 22299;
pub type icalparameter_patchaction = u32;
pub const icalparameter_range_ICAL_RANGE_X: icalparameter_range = 20700;
pub const icalparameter_range_ICAL_RANGE_THISANDPRIOR: icalparameter_range = 20701;
pub const icalparameter_range_ICAL_RANGE_THISANDFUTURE: icalparameter_range = 20702;
pub const icalparameter_range_ICAL_RANGE_NONE: icalparameter_range = 20799;
pub type icalparameter_range = u32;
pub const icalparameter_related_ICAL_RELATED_X: icalparameter_related = 20800;
pub const icalparameter_related_ICAL_RELATED_START: icalparameter_related = 20801;
pub const icalparameter_related_ICAL_RELATED_END: icalparameter_related = 20802;
pub const icalparameter_related_ICAL_RELATED_NONE: icalparameter_related = 20899;
pub type icalparameter_related = u32;
pub const icalparameter_reltype_ICAL_RELTYPE_X: icalparameter_reltype = 20900;
pub const icalparameter_reltype_ICAL_RELTYPE_PARENT: icalparameter_reltype = 20901;
pub const icalparameter_reltype_ICAL_RELTYPE_CHILD: icalparameter_reltype = 20902;
pub const icalparameter_reltype_ICAL_RELTYPE_SIBLING: icalparameter_reltype = 20903;
pub const icalparameter_reltype_ICAL_RELTYPE_POLL: icalparameter_reltype = 20904;
pub const icalparameter_reltype_ICAL_RELTYPE_NONE: icalparameter_reltype = 20999;
pub type icalparameter_reltype = u32;
pub const icalparameter_required_ICAL_REQUIRED_X: icalparameter_required = 21000;
pub const icalparameter_required_ICAL_REQUIRED_TRUE: icalparameter_required = 21001;
pub const icalparameter_required_ICAL_REQUIRED_FALSE: icalparameter_required = 21002;
pub const icalparameter_required_ICAL_REQUIRED_NONE: icalparameter_required = 21099;
pub type icalparameter_required = u32;
pub const icalparameter_role_ICAL_ROLE_X: icalparameter_role = 21100;
pub const icalparameter_role_ICAL_ROLE_CHAIR: icalparameter_role = 21101;
pub const icalparameter_role_ICAL_ROLE_REQPARTICIPANT: icalparameter_role = 21102;
pub const icalparameter_role_ICAL_ROLE_OPTPARTICIPANT: icalparameter_role = 21103;
pub const icalparameter_role_ICAL_ROLE_NONPARTICIPANT: icalparameter_role = 21104;
pub const icalparameter_role_ICAL_ROLE_NONE: icalparameter_role = 21199;
pub type icalparameter_role = u32;
pub const icalparameter_rsvp_ICAL_RSVP_X: icalparameter_rsvp = 21200;
pub const icalparameter_rsvp_ICAL_RSVP_TRUE: icalparameter_rsvp = 21201;
pub const icalparameter_rsvp_ICAL_RSVP_FALSE: icalparameter_rsvp = 21202;
pub const icalparameter_rsvp_ICAL_RSVP_NONE: icalparameter_rsvp = 21299;
pub type icalparameter_rsvp = u32;
pub const icalparameter_scheduleagent_ICAL_SCHEDULEAGENT_X: icalparameter_scheduleagent = 21300;
pub const icalparameter_scheduleagent_ICAL_SCHEDULEAGENT_SERVER: icalparameter_scheduleagent =
    21301;
pub const icalparameter_scheduleagent_ICAL_SCHEDULEAGENT_CLIENT: icalparameter_scheduleagent =
    21302;
pub const icalparameter_scheduleagent_ICAL_SCHEDULEAGENT_NONE: icalparameter_scheduleagent = 21399;
pub type icalparameter_scheduleagent = u32;
pub const icalparameter_scheduleforcesend_ICAL_SCHEDULEFORCESEND_X:
    icalparameter_scheduleforcesend = 21400;
pub const icalparameter_scheduleforcesend_ICAL_SCHEDULEFORCESEND_REQUEST:
    icalparameter_scheduleforcesend = 21401;
pub const icalparameter_scheduleforcesend_ICAL_SCHEDULEFORCESEND_REPLY:
    icalparameter_scheduleforcesend = 21402;
pub const icalparameter_scheduleforcesend_ICAL_SCHEDULEFORCESEND_NONE:
    icalparameter_scheduleforcesend = 21499;
pub type icalparameter_scheduleforcesend = u32;
pub const icalparameter_stayinformed_ICAL_STAYINFORMED_X: icalparameter_stayinformed = 21500;
pub const icalparameter_stayinformed_ICAL_STAYINFORMED_TRUE: icalparameter_stayinformed = 21501;
pub const icalparameter_stayinformed_ICAL_STAYINFORMED_FALSE: icalparameter_stayinformed = 21502;
pub const icalparameter_stayinformed_ICAL_STAYINFORMED_NONE: icalparameter_stayinformed = 21599;
pub type icalparameter_stayinformed = u32;
pub const icalparameter_substate_ICAL_SUBSTATE_X: icalparameter_substate = 21900;
pub const icalparameter_substate_ICAL_SUBSTATE_OK: icalparameter_substate = 21901;
pub const icalparameter_substate_ICAL_SUBSTATE_ERROR: icalparameter_substate = 21902;
pub const icalparameter_substate_ICAL_SUBSTATE_SUSPENDED: icalparameter_substate = 21903;
pub const icalparameter_substate_ICAL_SUBSTATE_NONE: icalparameter_substate = 21999;
pub type icalparameter_substate = u32;
pub const icalparameter_value_ICAL_VALUE_X: icalparameter_value = 21600;
pub const icalparameter_value_ICAL_VALUE_BINARY: icalparameter_value = 21601;
pub const icalparameter_value_ICAL_VALUE_BOOLEAN: icalparameter_value = 21602;
pub const icalparameter_value_ICAL_VALUE_DATE: icalparameter_value = 21603;
pub const icalparameter_value_ICAL_VALUE_DURATION: icalparameter_value = 21604;
pub const icalparameter_value_ICAL_VALUE_FLOAT: icalparameter_value = 21605;
pub const icalparameter_value_ICAL_VALUE_INTEGER: icalparameter_value = 21606;
pub const icalparameter_value_ICAL_VALUE_PERIOD: icalparameter_value = 21607;
pub const icalparameter_value_ICAL_VALUE_RECUR: icalparameter_value = 21608;
pub const icalparameter_value_ICAL_VALUE_TEXT: icalparameter_value = 21609;
pub const icalparameter_value_ICAL_VALUE_URI: icalparameter_value = 21610;
pub const icalparameter_value_ICAL_VALUE_ERROR: icalparameter_value = 21611;
pub const icalparameter_value_ICAL_VALUE_DATETIME: icalparameter_value = 21612;
pub const icalparameter_value_ICAL_VALUE_UTCOFFSET: icalparameter_value = 21613;
pub const icalparameter_value_ICAL_VALUE_CALADDRESS: icalparameter_value = 21614;
pub const icalparameter_value_ICAL_VALUE_NONE: icalparameter_value = 21699;
pub type icalparameter_value = u32;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_X: icalparameter_xliccomparetype =
    21700;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_EQUAL: icalparameter_xliccomparetype =
    21701;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_NOTEQUAL:
    icalparameter_xliccomparetype = 21702;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_LESS: icalparameter_xliccomparetype =
    21703;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_GREATER:
    icalparameter_xliccomparetype = 21704;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_LESSEQUAL:
    icalparameter_xliccomparetype = 21705;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_GREATEREQUAL:
    icalparameter_xliccomparetype = 21706;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_REGEX: icalparameter_xliccomparetype =
    21707;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_ISNULL: icalparameter_xliccomparetype =
    21708;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_ISNOTNULL:
    icalparameter_xliccomparetype = 21709;
pub const icalparameter_xliccomparetype_ICAL_XLICCOMPARETYPE_NONE: icalparameter_xliccomparetype =
    21799;
pub type icalparameter_xliccomparetype = u32;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_X: icalparameter_xlicerrortype = 21800;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_COMPONENTPARSEERROR:
    icalparameter_xlicerrortype = 21801;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_PROPERTYPARSEERROR:
    icalparameter_xlicerrortype = 21802;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_PARAMETERNAMEPARSEERROR:
    icalparameter_xlicerrortype = 21803;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_PARAMETERVALUEPARSEERROR:
    icalparameter_xlicerrortype = 21804;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_VALUEPARSEERROR:
    icalparameter_xlicerrortype = 21805;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_INVALIDITIP: icalparameter_xlicerrortype =
    21806;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_UNKNOWNVCALPROPERROR:
    icalparameter_xlicerrortype = 21807;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_MIMEPARSEERROR:
    icalparameter_xlicerrortype = 21808;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_VCALPROPPARSEERROR:
    icalparameter_xlicerrortype = 21809;
pub const icalparameter_xlicerrortype_ICAL_XLICERRORTYPE_NONE: icalparameter_xlicerrortype = 21899;
pub type icalparameter_xlicerrortype = u32;
extern "C" {
    pub fn icalparameter_new_actionparam(v: icalparameter_action) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_actionparam(value: *const icalparameter) -> icalparameter_action;
}
extern "C" {
    pub fn icalparameter_set_actionparam(value: *mut icalparameter, v: icalparameter_action);
}
extern "C" {
    pub fn icalparameter_new_altrep(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_altrep(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_altrep(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_charset(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_charset(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_charset(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_cn(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_cn(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_cn(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_cutype(v: icalparameter_cutype) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_cutype(value: *const icalparameter) -> icalparameter_cutype;
}
extern "C" {
    pub fn icalparameter_set_cutype(value: *mut icalparameter, v: icalparameter_cutype);
}
extern "C" {
    pub fn icalparameter_new_delegatedfrom(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_delegatedfrom(
        value: *const icalparameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_delegatedfrom(
        value: *mut icalparameter,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalparameter_new_delegatedto(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_delegatedto(
        value: *const icalparameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_delegatedto(
        value: *mut icalparameter,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalparameter_new_dir(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_dir(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_dir(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_display(v: icalparameter_display) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_display(value: *const icalparameter) -> icalparameter_display;
}
extern "C" {
    pub fn icalparameter_set_display(value: *mut icalparameter, v: icalparameter_display);
}
extern "C" {
    pub fn icalparameter_new_email(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_email(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_email(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_enable(v: icalparameter_enable) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_enable(value: *const icalparameter) -> icalparameter_enable;
}
extern "C" {
    pub fn icalparameter_set_enable(value: *mut icalparameter, v: icalparameter_enable);
}
extern "C" {
    pub fn icalparameter_new_encoding(v: icalparameter_encoding) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_encoding(value: *const icalparameter) -> icalparameter_encoding;
}
extern "C" {
    pub fn icalparameter_set_encoding(value: *mut icalparameter, v: icalparameter_encoding);
}
extern "C" {
    pub fn icalparameter_new_fbtype(v: icalparameter_fbtype) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_fbtype(value: *const icalparameter) -> icalparameter_fbtype;
}
extern "C" {
    pub fn icalparameter_set_fbtype(value: *mut icalparameter, v: icalparameter_fbtype);
}
extern "C" {
    pub fn icalparameter_new_feature(v: icalparameter_feature) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_feature(value: *const icalparameter) -> icalparameter_feature;
}
extern "C" {
    pub fn icalparameter_set_feature(value: *mut icalparameter, v: icalparameter_feature);
}
extern "C" {
    pub fn icalparameter_new_filename(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_filename(value: *const icalparameter)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_filename(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_fmttype(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_fmttype(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_fmttype(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_iana(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_iana(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_iana(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_id(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_id(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_id(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_label(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_label(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_label(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_language(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_language(value: *const icalparameter)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_language(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_latency(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_latency(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_latency(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_local(v: icalparameter_local) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_local(value: *const icalparameter) -> icalparameter_local;
}
extern "C" {
    pub fn icalparameter_set_local(value: *mut icalparameter, v: icalparameter_local);
}
extern "C" {
    pub fn icalparameter_new_localize(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_localize(value: *const icalparameter)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_localize(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_managedid(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_managedid(
        value: *const icalparameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_managedid(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_member(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_member(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_member(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_modified(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_modified(value: *const icalparameter)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_modified(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_options(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_options(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_options(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_partstat(v: icalparameter_partstat) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_partstat(value: *const icalparameter) -> icalparameter_partstat;
}
extern "C" {
    pub fn icalparameter_set_partstat(value: *mut icalparameter, v: icalparameter_partstat);
}
extern "C" {
    pub fn icalparameter_new_patchaction(v: icalparameter_patchaction) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_patchaction(value: *const icalparameter) -> icalparameter_patchaction;
}
extern "C" {
    pub fn icalparameter_set_patchaction(value: *mut icalparameter, v: icalparameter_patchaction);
}
extern "C" {
    pub fn icalparameter_new_publiccomment(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_publiccomment(
        value: *const icalparameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_publiccomment(
        value: *mut icalparameter,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalparameter_new_range(v: icalparameter_range) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_range(value: *const icalparameter) -> icalparameter_range;
}
extern "C" {
    pub fn icalparameter_set_range(value: *mut icalparameter, v: icalparameter_range);
}
extern "C" {
    pub fn icalparameter_new_reason(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_reason(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_reason(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_related(v: icalparameter_related) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_related(value: *const icalparameter) -> icalparameter_related;
}
extern "C" {
    pub fn icalparameter_set_related(value: *mut icalparameter, v: icalparameter_related);
}
extern "C" {
    pub fn icalparameter_new_reltype(v: icalparameter_reltype) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_reltype(value: *const icalparameter) -> icalparameter_reltype;
}
extern "C" {
    pub fn icalparameter_set_reltype(value: *mut icalparameter, v: icalparameter_reltype);
}
extern "C" {
    pub fn icalparameter_new_required(v: icalparameter_required) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_required(value: *const icalparameter) -> icalparameter_required;
}
extern "C" {
    pub fn icalparameter_set_required(value: *mut icalparameter, v: icalparameter_required);
}
extern "C" {
    pub fn icalparameter_new_response(v: ::std::os::raw::c_int) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_response(value: *const icalparameter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalparameter_set_response(value: *mut icalparameter, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalparameter_new_role(v: icalparameter_role) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_role(value: *const icalparameter) -> icalparameter_role;
}
extern "C" {
    pub fn icalparameter_set_role(value: *mut icalparameter, v: icalparameter_role);
}
extern "C" {
    pub fn icalparameter_new_rsvp(v: icalparameter_rsvp) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_rsvp(value: *const icalparameter) -> icalparameter_rsvp;
}
extern "C" {
    pub fn icalparameter_set_rsvp(value: *mut icalparameter, v: icalparameter_rsvp);
}
extern "C" {
    pub fn icalparameter_new_scheduleagent(v: icalparameter_scheduleagent) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_scheduleagent(
        value: *const icalparameter,
    ) -> icalparameter_scheduleagent;
}
extern "C" {
    pub fn icalparameter_set_scheduleagent(
        value: *mut icalparameter,
        v: icalparameter_scheduleagent,
    );
}
extern "C" {
    pub fn icalparameter_new_scheduleforcesend(
        v: icalparameter_scheduleforcesend,
    ) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_scheduleforcesend(
        value: *const icalparameter,
    ) -> icalparameter_scheduleforcesend;
}
extern "C" {
    pub fn icalparameter_set_scheduleforcesend(
        value: *mut icalparameter,
        v: icalparameter_scheduleforcesend,
    );
}
extern "C" {
    pub fn icalparameter_new_schedulestatus(v: *const ::std::os::raw::c_char)
        -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_schedulestatus(
        value: *const icalparameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_schedulestatus(
        value: *mut icalparameter,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalparameter_new_sentby(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_sentby(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_sentby(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_size(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_size(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_size(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_stayinformed(v: icalparameter_stayinformed) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_stayinformed(
        value: *const icalparameter,
    ) -> icalparameter_stayinformed;
}
extern "C" {
    pub fn icalparameter_set_stayinformed(value: *mut icalparameter, v: icalparameter_stayinformed);
}
extern "C" {
    pub fn icalparameter_new_substate(v: icalparameter_substate) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_substate(value: *const icalparameter) -> icalparameter_substate;
}
extern "C" {
    pub fn icalparameter_set_substate(value: *mut icalparameter, v: icalparameter_substate);
}
extern "C" {
    pub fn icalparameter_new_tzid(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_tzid(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_tzid(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_value(v: icalparameter_value) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_value(value: *const icalparameter) -> icalparameter_value;
}
extern "C" {
    pub fn icalparameter_set_value(value: *mut icalparameter, v: icalparameter_value);
}
extern "C" {
    pub fn icalparameter_new_x(v: *const ::std::os::raw::c_char) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_x(value: *const icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_set_x(value: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalparameter_new_xliccomparetype(
        v: icalparameter_xliccomparetype,
    ) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_xliccomparetype(
        value: *const icalparameter,
    ) -> icalparameter_xliccomparetype;
}
extern "C" {
    pub fn icalparameter_set_xliccomparetype(
        value: *mut icalparameter,
        v: icalparameter_xliccomparetype,
    );
}
extern "C" {
    pub fn icalparameter_new_xlicerrortype(v: icalparameter_xlicerrortype) -> *mut icalparameter;
}
extern "C" {
    pub fn icalparameter_get_xlicerrortype(
        value: *const icalparameter,
    ) -> icalparameter_xlicerrortype;
}
extern "C" {
    pub fn icalparameter_set_xlicerrortype(
        value: *mut icalparameter,
        v: icalparameter_xlicerrortype,
    );
}
extern "C" {
    pub fn icalvalue_new(kind: icalvalue_kind) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_new_clone(value: *const icalvalue) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_new_from_string(
        kind: icalvalue_kind,
        str: *const ::std::os::raw::c_char,
    ) -> *mut icalvalue;
}
extern "C" {
    pub fn icalvalue_free(value: *mut icalvalue);
}
extern "C" {
    pub fn icalvalue_is_valid(value: *const icalvalue) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalvalue_as_ical_string(value: *const icalvalue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_as_ical_string_r(value: *const icalvalue) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalvalue_isa(value: *const icalvalue) -> icalvalue_kind;
}
extern "C" {
    pub fn icalvalue_isa_value(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalvalue_compare(
        a: *const icalvalue,
        b: *const icalvalue,
    ) -> icalparameter_xliccomparetype;
}
extern "C" {
    pub fn icalvalue_string_to_kind(str: *const ::std::os::raw::c_char) -> icalvalue_kind;
}
extern "C" {
    pub fn icalvalue_kind_to_string(kind: icalvalue_kind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Check validity of a specific icalvalue_kind
    pub fn icalvalue_kind_is_valid(kind: icalvalue_kind) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Encode a character string in ical format, esacpe certain characters, etc.
    pub fn icalvalue_encode_ical_string(
        szText: *const ::std::os::raw::c_char,
        szEncText: *mut ::std::os::raw::c_char,
        MaxBufferLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Extract the original character string encoded by the above function
    pub fn icalvalue_decode_ical_string(
        szText: *const ::std::os::raw::c_char,
        szDecText: *mut ::std::os::raw::c_char,
        nMaxBufferLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_date_to_string(str: *mut ::std::os::raw::c_char, data: *const icaltimetype);
}
extern "C" {
    pub fn print_datetime_to_string(str: *mut ::std::os::raw::c_char, data: *const icaltimetype);
}
extern "C" {
    /// @brief Creates new ::icalparameter object.
    /// @param kind The kind of ::icalparameter to create.
    /// @return An ::icalparameter with the given kind.
    ///
    /// @par Error handling
    /// If there was an internal error regarding
    /// memory allocation, it returns `NULL` and sets
    /// ::icalerrno to ::ICAL_NEWFAILED_ERROR.
    ///
    /// @par Ownership
    /// Objects created by this method are owned by the caller and
    /// must be released with the icalparameter_free() method.
    ///
    /// ### Usage
    /// ```c
    /// // create new parameter
    /// icalparameter *parameter = icalparameter_new();
    ///
    /// if(parameter) {
    ///     // use parameter ...
    /// }
    ///
    /// // release parameter
    /// icalparameter_free(parameter);
    /// ```
    pub fn icalparameter_new(kind: icalparameter_kind) -> *mut icalparameter;
}
extern "C" {
    /// @brief Creates new ::icalparameter as a clone of the given one.
    /// @param p The existing, non-`NULL` parameter to clone.
    /// @return An ::icalparameter that is a clone of the given one.
    ///
    /// @par Error handling
    /// If @a p is `NULL`, it returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR.
    /// If there was an internal error cloning the data, it returns `NULL`
    /// without reporting any error in ::icalerrno.
    ///
    /// @par Ownership
    /// Objects created by this method are owned by the caller and
    /// must be released with the icalparameter_free() method.
    ///
    /// ### Usage
    /// ```x
    /// // create an icalparameter
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// // clone the parameter
    /// icalparameter *clone = icalparameter_new_clone(param);
    ///
    /// if(clone) {
    ///     // use clone ...
    /// }
    ///
    /// // release parameters
    /// icalparameter_free(param);
    /// icalparameter_free(clone);
    /// ```
    pub fn icalparameter_new_clone(p: *mut icalparameter) -> *mut icalparameter;
}
extern "C" {
    /// @brief Create ::icalparameter object from string
    /// @param value The string from which to create the ::icalparameter, in the form `"PARAMNAME=VALUE"`
    /// @return An ::icalparameter that corresponds to the given string.
    ///
    /// @par Error handling
    /// If there was an internal error copying data, it returns `NULL` and sets
    /// ::icalerrno to ::ICAL_NEWFAILED_ERROR. If @a value was `NULL`, it returns
    /// `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR. If @a value was malformed,
    /// it returns `NULL` and sets ::icalerrno to ::ICAL_MALFORMEDDATA_ERROR.
    ///
    /// @par Ownership
    /// Objects created by this method are owned by the caller and
    /// must be released with the icalparameter_free() method.
    ///
    /// ### Usage
    /// ```c
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// if(param) {
    ///     // use param ...
    /// }
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_new_from_string(
        value: *const ::std::os::raw::c_char,
    ) -> *mut icalparameter;
}
extern "C" {
    /// @brief Create ::icalparameter of a given @a kind with a given @a value
    /// @param kind The kind of ::icalparameter to create
    /// @param value The value of the parameter
    /// @return An ::icalparameter with the given kind and value.
    ///
    /// @par Error handling
    /// If value is `NULL`, it returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR.
    ///
    /// @par Ownership
    /// Objects created by this method are owned by the caller and
    /// must be released with the icalparameter_free() method.
    ///
    /// ### Example
    /// ```c
    /// // create new parameter
    /// icalparameter *param;
    /// param = icalparameter_new_from_value_string(ICAL_ROLE_PARAMETER, "CHAIR");
    ///
    /// // check parameter
    /// assert(0 == strcmp(icalparameter_get_iana_name(param), "ROLE"));
    /// assert(0 == strcmp(icalparameter_get_iana_value(param), "CHAIR"));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_new_from_value_string(
        kind: icalparameter_kind,
        value: *const ::std::os::raw::c_char,
    ) -> *mut icalparameter;
}
extern "C" {
    /// @brief Frees an ::icalparameter object.
    /// @param parameter The icalparameter to free
    ///
    /// This method needs to be used on all parameter objects returned
    /// from any of the `_new()` methods including icalparameter_new(), icalparameter_new_clone(),
    /// icalparameter_new_from_string() and icalparameter_new_from_value_string(),
    /// when they are not needed anymore and to be released.
    ///
    /// ### Usage
    /// ```c
    /// icalparameter *param = icalparameter_new();
    ///
    /// if(param) {
    ///     // use param...
    /// }
    ///
    /// // after use, release it
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_free(parameter: *mut icalparameter);
}
extern "C" {
    /// @brief Convert ::icalparameter into an string representation
    /// @param parameter The ::icalparameter to convert
    /// @return A string representing the parameter according to RFC5445/RFC6868.
    /// @sa icalparameter_as_ical_string_r()
    ///
    /// @par Error handling
    /// If there is any error, the method returns `NULL`. Furthermore,
    /// if @a parameter is `NULL`, it also sets ::icalerrno to ::ICAL_BADARG_ERROR.
    /// If it doesn't recognize the kind of the parameter, it sets ::icalerrno
    /// it ::ICAL_BADARG_ERROR. If the parameter is otherwise malformed, it
    /// sets ::icalerrno to ::ICAL_MALFORMEDDATA_ERROR.
    ///
    /// @par Ownership
    /// Strings returned by this method are owned by libical, they must
    /// not be freed and they may be reclaimed with the next call into
    /// the library. A version of this function, which returns strings
    /// that are not owned by libical, is icalparameter_as_ical_string_r().
    ///
    /// ### Usage
    /// ```c
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// if(param) {
    ///     printf("%s\n", icalparameter_as_ical_string(param));
    /// }
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_as_ical_string(
        parameter: *mut icalparameter,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Convert ::icalparameter into an string representation
    /// @param parameter The ::icalparameter to convert
    /// @return A string representing the parameter according to RFC5445/RFC6868.
    /// @sa icalparameter_as_ical_string()
    ///
    /// @par Error handling
    /// If there is any error, the method returns `NULL`. Furthermore,
    /// if parameter is `NULL`, it also sets ::icalerrno to ::ICAL_BADARG_ERROR.
    /// If it doesn't recognize the kind of the parameter, it sets ::icalerrno
    /// to ::ICAL_BADARG_ERROR. If the parameter is otherwise malformed, it
    /// sets ::icalerrno to ::ICAL_MALFORMEDDATA_ERROR.
    ///
    /// @par Ownership
    /// Strings returned by this method are owned by the caller, thus they need
    /// to be manually `free()`d after use. A version of this function which returns
    /// strings that do not need to be freed manually is
    /// icalparameter_as_ical_string().
    ///
    /// ### Usage
    /// ```c
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// if(param) {
    ///     char *str = icalparameter_as_ical_string(param);
    ///     printf("%s\n", str);
    ///     free(str);
    /// }
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_as_ical_string_r(
        parameter: *mut icalparameter,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Returns the icalparameter_kind of parameter.
    ///
    /// @param parameter The icalparameter whose kind to determine
    /// @return The icalparameter_kind of the parameter
    ///
    /// @b Error handling
    /// Returns ICAL_NO_PARAMETER when passed NULL.
    ///
    /// @b Usage
    /// @code
    /// // create parameter
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// // check what type of parameter this is
    /// assert(icalparameter_isa(param) == ICAL_ROLE_PARAMETER);
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// @endcode
    pub fn icalparameter_isa(parameter: *mut icalparameter) -> icalparameter_kind;
}
extern "C" {
    /// Determine if the given param is an icalparameter
    /// @param param The libical-originated object to check
    /// @return 1 if the object is an icalparameter, 0 otherwise.
    /// @note This function expects to be given an object originating from
    ///  libical - if this function is passed anything that is not from
    ///  libical, it's behavior is undefined.
    ///
    /// @b Error handling
    /// When given a `NULL` object, it returns 0.
    ///
    /// @b Usage
    /// ```c
    /// // create parameter
    /// icalparameter *param = icalparameter_new_from_string("ROLE=CHAIR");
    ///
    /// // check if it's a parameter
    /// assert(icalparameter_isa_parameter(param));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_isa_parameter(param: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Sets the X-name of @a param to @a v
    /// @param param The ::icalparameter to change
    /// @param v The X-name to set @a param to
    /// @sa icalparameter_get_xname()
    ///
    /// @par Error handling
    /// If either @a param or @a v are `NULL`, it sets ::icalerrno to ::ICAL_BARARG_ERROR.
    /// If there is an error acquiring memory, it sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The passed string @a v stays in the ownership of the caller - libical
    /// creates a copy of it.
    ///
    /// ### Usage
    /// ```c
    /// // creates new parameter
    /// icalparameter *param = icalparameter_new();
    ///
    /// // sets xname
    /// icalparameter_set_xname(param, "X-TEST");
    ///
    /// // compare xname
    /// assert(0 == strcmp(icalparameter_get_xname(param), "X-TEST"));
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_set_xname(param: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    /// @brief Returns the X-name of @a param
    /// @param param The ::icalparameter whose X-name is to be returned
    /// @return A string representing the X-name of @a param
    /// @sa icalparameter_set_xname()
    ///
    /// @par Error handling
    /// Returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR when a `NULL`
    /// is passed instead of an ::icalparameter.
    ///
    /// @par Ownership
    /// The string that is returned stays owned by libical and must not
    /// be freed by the caller.
    ///
    /// ### Usage
    /// ```c
    /// // creates new parameter
    /// icalparameter *param = icalparameter_new();
    ///
    /// // sets xname
    /// icalparameter_set_xname(param, "X-TEST");
    ///
    /// // compare xname
    /// assert(0 == strcmp(icalparameter_get_xname(param), "X-TEST"));
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_get_xname(param: *mut icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Sets the X-value of @a param to @a v
    /// @param param The ::icalparameter to change
    /// @param v The X-value to set @a param to
    /// @sa icalparameter_get_xvalue()
    ///
    /// @par Error handling
    /// If either @a param or @a v are `NULL`, it sets ::icalerrno to ::ICAL_BARARG_ERROR.
    /// If there is an error acquiring memory, it sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The passed string @a v stays in the ownership of the caller - libical
    /// creates a copy of it.
    ///
    /// ### Usage
    /// ```c
    /// // create new parameter
    /// icalparameter *param = icalparameter_new_from_string("X-TEST=FAIL");
    ///
    /// // set test to success
    /// icalparameter_set_xvalue(param, "SUCCESS");
    ///
    /// // check that it worked
    /// assert(0 == strcmp(icalparameter_get_xvalue(param), "SUCCESS"));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_set_xvalue(param: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    /// @brief Returns the X-value of @a param
    /// @param param The ::icalparameter whose X-value is to be returned
    /// @return A string representing the X-value of @a param
    /// @sa icalparameter_set_xvalue()
    ///
    /// @par Error handling
    /// Returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR when a `NULL`
    /// is passed instead of an ::icalparameter.
    ///
    /// @par Ownership
    /// The string that is returned stays owned by libical and must not
    /// be freed by the caller.
    ///
    /// ### Usage
    /// ```c
    /// // create new parameter
    /// icalparameter *param = icalparameter_new_from_string("X-TEST=FAIL");
    ///
    /// // set test to success
    /// icalparameter_set_xvalue(param, "SUCCESS");
    ///
    /// // check that it worked
    /// assert(0 == strcmp(icalparameter_get_xvalue(param), "SUCCESS"));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_get_xvalue(param: *mut icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Sets the IANA name of @a param to @a v
    /// @param param The icalparameter to change
    /// @param v The IANA name to set @a param to
    /// @sa icalparameter_get_iana_name()
    ///
    /// @par Error handling
    /// If either @a param or @a v are `NULL`, it sets ::icalerrno to ::ICAL_BARARG_ERROR.
    /// If there is an error acquiring memory, it sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The passed string @a v stays in the ownership of the caller - libical
    /// creates a copy of it.
    ///
    /// ### Usage
    /// ```c
    /// // creates new parameter
    /// icalparameter *param = icalparameter_new();
    ///
    /// // sets iana name
    /// icalparameter_set_iana_name(param, "ROLE");
    ///
    /// // compare iana name
    /// assert(0 == strcmp(icalparameter_get_iana_name(param), "X-TEST"));
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_set_iana_name(param: *mut icalparameter, v: *const ::std::os::raw::c_char);
}
extern "C" {
    /// @brief Returns the IANA name of @a param
    /// @param param The ::icalparameter whose IANA name is to be returned
    /// @return A string representing the IANA name of @a param
    /// @sa icalparameter_set_iana_name()
    ///
    /// @par Error handling
    /// Returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR when a `NULL`
    /// is passed instead of an ::icalparameter.
    ///
    /// @par Ownership
    /// The string that is returned stays owned by libical and must not
    /// be freed by the caller.
    ///
    /// ### Usage
    /// ```c
    /// // creates new parameter
    /// icalparameter *param = icalparameter_new();
    ///
    /// // sets iana name
    /// icalparameter_set_iana_name(param, "X-TEST");
    ///
    /// // compare iana name
    /// assert(0 == strcmp(icalparameter_get_iana_name(param), "X-TEST"));
    ///
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_get_iana_name(param: *mut icalparameter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Sets the IANA value of @a param to @a v
    /// @param param The ::icalparameter to change
    /// @param v The IANA value to set @a param to
    /// @sa icalparameter_get_iana_value()
    ///
    /// @par Error handling
    /// If either @a param or @a v are `NULL`, it sets ::icalerrno to ::ICAL_BARARG_ERROR.
    /// If there is an error acquiring memory, it sets `errno` to `ENOMEM`.
    ///
    /// @par Ownership
    /// The passed string @a v stays in the ownership of the caller - libical
    /// creates a copy of it.
    ///
    /// ### Usage
    /// ```c
    /// // create new parameter
    /// icalparameter *param = icalparameter_new_from_string("ROLE=ATTENDEE");
    ///
    /// // set role to chair
    /// icalparameter_set_iana_value(param, "CHAIR");
    ///
    /// // check that it worked
    /// assert(0 == strcmp(icalparameter_get_iana_value(param), "SUCCESS"));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_set_iana_value(
        param: *mut icalparameter,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Returns the IANA value of @a param
    /// @param param The ::icalparameter whose value is to be returned
    /// @return A string representing the value of @a param
    /// @sa icalparameter_set_iana_value()
    ///
    /// @par Error handling
    /// Returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR when a `NULL`
    /// is passed instead of an ::icalparameter.
    ///
    /// @par Ownership
    /// The string that is returned stays owned by libical and must not
    /// be freed by the caller.
    ///
    /// ### Usage
    /// ```c
    /// // create new parameter
    /// icalparameter *param = icalparameter_new_from_string("ROLE=ATTENDEE");
    ///
    /// // set role to chair
    /// icalparameter_set_iana_value(param, "CHAIR");
    ///
    /// // check that it worked
    /// assert(0 == strcmp(icalparameter_get_iana_value(param), "SUCCESS"));
    ///
    /// // release memory
    /// icalparameter_free(param);
    /// ```
    pub fn icalparameter_get_iana_value(param: *mut icalparameter)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Determines if two parameters have the same name
    /// @param param1 First parameter to compare
    /// @param param2 Second parameter to compare
    /// @return 1 if they have the same name, 0 otherwise.
    ///
    /// @par Error handling
    /// If either of @a param1 or @a param2 are `NULL`, it returns 0 and sets
    /// ::icalerrno to ::ICAL_BADARG_ERROR.
    ///
    /// @par Ownership
    /// Does not take ownership of either ::icalparameter.
    ///
    /// ### Example
    /// ```c
    /// // create two parameters
    /// icalparameter *param1 = icalparameter_new_from_string("ROLE=CHAIR");
    /// icalparameter *param2 = icalparameter_new_from_string("EMAIL=mailto@example.com");
    ///
    /// // compare parameter names for equality
    /// assert(icalparameter_has_same_name(param1, param2) == 0);
    ///
    /// // release memory
    /// icalparameter_free(param1);
    /// icalparameter_free(param2);
    /// ```
    pub fn icalparameter_has_same_name(
        param1: *mut icalparameter,
        param2: *mut icalparameter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Returns a string representing the given ::icalparameter_kind
    /// @param kind The icalparameter_kind
    /// @return A string representing kind
    ///
    /// @par Error handling
    /// When passed a non-existing ::icalparameter_kind, it returns `NULL`.
    ///
    /// @par Ownership
    /// The string that is returned by this function is owned by libical and
    /// must not be freed by the caller.
    ///
    /// ### Usage
    /// ```c
    /// assert(0 == strcmp(icalparameter_kind_to_string(ICAL_ROLE_PARAMETER), "ROLE"));
    /// assert(0 == strcmp(icalparameter_kind_to_string(ICAL_EMAIL_PARAMETER), "EMAIL));
    /// assert(0 == strcmp(icalparameter_kind_to_string(ICAL_ID_PARAMETER), "ID"));
    /// ```
    pub fn icalparameter_kind_to_string(kind: icalparameter_kind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Returns the ::icalparameter_kind for a given string
    /// @param string A string describing an icalparameter_kind
    /// @return An icalparameter_kind
    ///
    /// @par Error handling
    /// Returns ::ICAL_NO_PARAMETER if @a string is `NULL`.
    /// If it can't find the parameter, depending on
    /// the ical_get_unknown_token_handling_setting(), it returns either
    /// ::ICAL_NO_PARAMETER or ::ICAL_IANA_PARAMETER.
    ///
    /// @par Ownership
    /// Does not take ownership of @a string.
    ///
    /// ### Usage
    /// ```c
    /// assert(icalparameter_string_to_kind("ROLE")  == ICAL_ROLE_PARAMETER);
    /// assert(icalparameter_string_to_kind("EMAIL") == ICAL_EMAIL_PARAMETER);
    /// assert(icalparameter_string_to_kind("ID")    == ICAL_ID_PARAMETER);
    /// ```
    pub fn icalparameter_string_to_kind(
        string: *const ::std::os::raw::c_char,
    ) -> icalparameter_kind;
}
extern "C" {
    /// @brief Checks the validity of a ::icalparameter_kind
    /// @param kind The icalparameter_kind
    /// @return 1 if if the kind is valid, 0 otherwise
    ///
    /// ### Usage
    /// ```c
    /// assert(icalparameter_kind_is_valid(ICAL_ROLE_PARAMETER));
    /// ```
    /// @since 3.0.4
    pub fn icalparameter_kind_is_valid(kind: icalparameter_kind) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalproperty_impl {
    _unused: [u8; 0],
}
pub type icalproperty = icalproperty_impl;
pub const icalproperty_kind_ICAL_ANY_PROPERTY: icalproperty_kind = 0;
pub const icalproperty_kind_ICAL_ACCEPTRESPONSE_PROPERTY: icalproperty_kind = 102;
pub const icalproperty_kind_ICAL_ACKNOWLEDGED_PROPERTY: icalproperty_kind = 1;
pub const icalproperty_kind_ICAL_ACTION_PROPERTY: icalproperty_kind = 2;
pub const icalproperty_kind_ICAL_ALLOWCONFLICT_PROPERTY: icalproperty_kind = 3;
pub const icalproperty_kind_ICAL_ATTACH_PROPERTY: icalproperty_kind = 4;
pub const icalproperty_kind_ICAL_ATTENDEE_PROPERTY: icalproperty_kind = 5;
pub const icalproperty_kind_ICAL_BUSYTYPE_PROPERTY: icalproperty_kind = 101;
pub const icalproperty_kind_ICAL_CALID_PROPERTY: icalproperty_kind = 6;
pub const icalproperty_kind_ICAL_CALMASTER_PROPERTY: icalproperty_kind = 7;
pub const icalproperty_kind_ICAL_CALSCALE_PROPERTY: icalproperty_kind = 8;
pub const icalproperty_kind_ICAL_CAPVERSION_PROPERTY: icalproperty_kind = 9;
pub const icalproperty_kind_ICAL_CARLEVEL_PROPERTY: icalproperty_kind = 10;
pub const icalproperty_kind_ICAL_CARID_PROPERTY: icalproperty_kind = 11;
pub const icalproperty_kind_ICAL_CATEGORIES_PROPERTY: icalproperty_kind = 12;
pub const icalproperty_kind_ICAL_CLASS_PROPERTY: icalproperty_kind = 13;
pub const icalproperty_kind_ICAL_CMD_PROPERTY: icalproperty_kind = 14;
pub const icalproperty_kind_ICAL_COLOR_PROPERTY: icalproperty_kind = 118;
pub const icalproperty_kind_ICAL_COMMENT_PROPERTY: icalproperty_kind = 15;
pub const icalproperty_kind_ICAL_COMPLETED_PROPERTY: icalproperty_kind = 16;
pub const icalproperty_kind_ICAL_COMPONENTS_PROPERTY: icalproperty_kind = 17;
pub const icalproperty_kind_ICAL_CONFERENCE_PROPERTY: icalproperty_kind = 120;
pub const icalproperty_kind_ICAL_CONTACT_PROPERTY: icalproperty_kind = 18;
pub const icalproperty_kind_ICAL_CREATED_PROPERTY: icalproperty_kind = 19;
pub const icalproperty_kind_ICAL_CSID_PROPERTY: icalproperty_kind = 20;
pub const icalproperty_kind_ICAL_DATEMAX_PROPERTY: icalproperty_kind = 21;
pub const icalproperty_kind_ICAL_DATEMIN_PROPERTY: icalproperty_kind = 22;
pub const icalproperty_kind_ICAL_DECREED_PROPERTY: icalproperty_kind = 23;
pub const icalproperty_kind_ICAL_DEFAULTCHARSET_PROPERTY: icalproperty_kind = 24;
pub const icalproperty_kind_ICAL_DEFAULTLOCALE_PROPERTY: icalproperty_kind = 25;
pub const icalproperty_kind_ICAL_DEFAULTTZID_PROPERTY: icalproperty_kind = 26;
pub const icalproperty_kind_ICAL_DEFAULTVCARS_PROPERTY: icalproperty_kind = 27;
pub const icalproperty_kind_ICAL_DENY_PROPERTY: icalproperty_kind = 28;
pub const icalproperty_kind_ICAL_DESCRIPTION_PROPERTY: icalproperty_kind = 29;
pub const icalproperty_kind_ICAL_DTEND_PROPERTY: icalproperty_kind = 30;
pub const icalproperty_kind_ICAL_DTSTAMP_PROPERTY: icalproperty_kind = 31;
pub const icalproperty_kind_ICAL_DTSTART_PROPERTY: icalproperty_kind = 32;
pub const icalproperty_kind_ICAL_DUE_PROPERTY: icalproperty_kind = 33;
pub const icalproperty_kind_ICAL_DURATION_PROPERTY: icalproperty_kind = 34;
pub const icalproperty_kind_ICAL_ESTIMATEDDURATION_PROPERTY: icalproperty_kind = 113;
pub const icalproperty_kind_ICAL_EXDATE_PROPERTY: icalproperty_kind = 35;
pub const icalproperty_kind_ICAL_EXPAND_PROPERTY: icalproperty_kind = 36;
pub const icalproperty_kind_ICAL_EXRULE_PROPERTY: icalproperty_kind = 37;
pub const icalproperty_kind_ICAL_FREEBUSY_PROPERTY: icalproperty_kind = 38;
pub const icalproperty_kind_ICAL_GEO_PROPERTY: icalproperty_kind = 39;
pub const icalproperty_kind_ICAL_GRANT_PROPERTY: icalproperty_kind = 40;
pub const icalproperty_kind_ICAL_IMAGE_PROPERTY: icalproperty_kind = 119;
pub const icalproperty_kind_ICAL_ITIPVERSION_PROPERTY: icalproperty_kind = 41;
pub const icalproperty_kind_ICAL_LASTMODIFIED_PROPERTY: icalproperty_kind = 42;
pub const icalproperty_kind_ICAL_LOCATION_PROPERTY: icalproperty_kind = 43;
pub const icalproperty_kind_ICAL_MAXCOMPONENTSIZE_PROPERTY: icalproperty_kind = 44;
pub const icalproperty_kind_ICAL_MAXDATE_PROPERTY: icalproperty_kind = 45;
pub const icalproperty_kind_ICAL_MAXRESULTS_PROPERTY: icalproperty_kind = 46;
pub const icalproperty_kind_ICAL_MAXRESULTSSIZE_PROPERTY: icalproperty_kind = 47;
pub const icalproperty_kind_ICAL_METHOD_PROPERTY: icalproperty_kind = 48;
pub const icalproperty_kind_ICAL_MINDATE_PROPERTY: icalproperty_kind = 49;
pub const icalproperty_kind_ICAL_MULTIPART_PROPERTY: icalproperty_kind = 50;
pub const icalproperty_kind_ICAL_NAME_PROPERTY: icalproperty_kind = 115;
pub const icalproperty_kind_ICAL_ORGANIZER_PROPERTY: icalproperty_kind = 52;
pub const icalproperty_kind_ICAL_OWNER_PROPERTY: icalproperty_kind = 53;
pub const icalproperty_kind_ICAL_PATCHDELETE_PROPERTY: icalproperty_kind = 124;
pub const icalproperty_kind_ICAL_PATCHORDER_PROPERTY: icalproperty_kind = 122;
pub const icalproperty_kind_ICAL_PATCHPARAMETER_PROPERTY: icalproperty_kind = 125;
pub const icalproperty_kind_ICAL_PATCHTARGET_PROPERTY: icalproperty_kind = 123;
pub const icalproperty_kind_ICAL_PATCHVERSION_PROPERTY: icalproperty_kind = 121;
pub const icalproperty_kind_ICAL_PERCENTCOMPLETE_PROPERTY: icalproperty_kind = 54;
pub const icalproperty_kind_ICAL_PERMISSION_PROPERTY: icalproperty_kind = 55;
pub const icalproperty_kind_ICAL_POLLCOMPLETION_PROPERTY: icalproperty_kind = 110;
pub const icalproperty_kind_ICAL_POLLITEMID_PROPERTY: icalproperty_kind = 103;
pub const icalproperty_kind_ICAL_POLLMODE_PROPERTY: icalproperty_kind = 104;
pub const icalproperty_kind_ICAL_POLLPROPERTIES_PROPERTY: icalproperty_kind = 105;
pub const icalproperty_kind_ICAL_POLLWINNER_PROPERTY: icalproperty_kind = 106;
pub const icalproperty_kind_ICAL_PRIORITY_PROPERTY: icalproperty_kind = 56;
pub const icalproperty_kind_ICAL_PRODID_PROPERTY: icalproperty_kind = 57;
pub const icalproperty_kind_ICAL_QUERY_PROPERTY: icalproperty_kind = 58;
pub const icalproperty_kind_ICAL_QUERYLEVEL_PROPERTY: icalproperty_kind = 59;
pub const icalproperty_kind_ICAL_QUERYID_PROPERTY: icalproperty_kind = 60;
pub const icalproperty_kind_ICAL_QUERYNAME_PROPERTY: icalproperty_kind = 61;
pub const icalproperty_kind_ICAL_RDATE_PROPERTY: icalproperty_kind = 62;
pub const icalproperty_kind_ICAL_RECURACCEPTED_PROPERTY: icalproperty_kind = 63;
pub const icalproperty_kind_ICAL_RECUREXPAND_PROPERTY: icalproperty_kind = 64;
pub const icalproperty_kind_ICAL_RECURLIMIT_PROPERTY: icalproperty_kind = 65;
pub const icalproperty_kind_ICAL_RECURRENCEID_PROPERTY: icalproperty_kind = 66;
pub const icalproperty_kind_ICAL_REFRESHINTERVAL_PROPERTY: icalproperty_kind = 116;
pub const icalproperty_kind_ICAL_RELATEDTO_PROPERTY: icalproperty_kind = 67;
pub const icalproperty_kind_ICAL_RELCALID_PROPERTY: icalproperty_kind = 68;
pub const icalproperty_kind_ICAL_REPEAT_PROPERTY: icalproperty_kind = 69;
pub const icalproperty_kind_ICAL_REPLYURL_PROPERTY: icalproperty_kind = 111;
pub const icalproperty_kind_ICAL_REQUESTSTATUS_PROPERTY: icalproperty_kind = 70;
pub const icalproperty_kind_ICAL_RESOURCES_PROPERTY: icalproperty_kind = 71;
pub const icalproperty_kind_ICAL_RESPONSE_PROPERTY: icalproperty_kind = 112;
pub const icalproperty_kind_ICAL_RESTRICTION_PROPERTY: icalproperty_kind = 72;
pub const icalproperty_kind_ICAL_RRULE_PROPERTY: icalproperty_kind = 73;
pub const icalproperty_kind_ICAL_SCOPE_PROPERTY: icalproperty_kind = 74;
pub const icalproperty_kind_ICAL_SEQUENCE_PROPERTY: icalproperty_kind = 75;
pub const icalproperty_kind_ICAL_SOURCE_PROPERTY: icalproperty_kind = 117;
pub const icalproperty_kind_ICAL_STATUS_PROPERTY: icalproperty_kind = 76;
pub const icalproperty_kind_ICAL_STORESEXPANDED_PROPERTY: icalproperty_kind = 77;
pub const icalproperty_kind_ICAL_SUMMARY_PROPERTY: icalproperty_kind = 78;
pub const icalproperty_kind_ICAL_TARGET_PROPERTY: icalproperty_kind = 79;
pub const icalproperty_kind_ICAL_TASKMODE_PROPERTY: icalproperty_kind = 114;
pub const icalproperty_kind_ICAL_TRANSP_PROPERTY: icalproperty_kind = 80;
pub const icalproperty_kind_ICAL_TRIGGER_PROPERTY: icalproperty_kind = 81;
pub const icalproperty_kind_ICAL_TZID_PROPERTY: icalproperty_kind = 82;
pub const icalproperty_kind_ICAL_TZIDALIASOF_PROPERTY: icalproperty_kind = 108;
pub const icalproperty_kind_ICAL_TZNAME_PROPERTY: icalproperty_kind = 83;
pub const icalproperty_kind_ICAL_TZOFFSETFROM_PROPERTY: icalproperty_kind = 84;
pub const icalproperty_kind_ICAL_TZOFFSETTO_PROPERTY: icalproperty_kind = 85;
pub const icalproperty_kind_ICAL_TZUNTIL_PROPERTY: icalproperty_kind = 109;
pub const icalproperty_kind_ICAL_TZURL_PROPERTY: icalproperty_kind = 86;
pub const icalproperty_kind_ICAL_UID_PROPERTY: icalproperty_kind = 87;
pub const icalproperty_kind_ICAL_URL_PROPERTY: icalproperty_kind = 88;
pub const icalproperty_kind_ICAL_VERSION_PROPERTY: icalproperty_kind = 89;
pub const icalproperty_kind_ICAL_VOTER_PROPERTY: icalproperty_kind = 107;
pub const icalproperty_kind_ICAL_X_PROPERTY: icalproperty_kind = 90;
pub const icalproperty_kind_ICAL_XLICCLASS_PROPERTY: icalproperty_kind = 91;
pub const icalproperty_kind_ICAL_XLICCLUSTERCOUNT_PROPERTY: icalproperty_kind = 92;
pub const icalproperty_kind_ICAL_XLICERROR_PROPERTY: icalproperty_kind = 93;
pub const icalproperty_kind_ICAL_XLICMIMECHARSET_PROPERTY: icalproperty_kind = 94;
pub const icalproperty_kind_ICAL_XLICMIMECID_PROPERTY: icalproperty_kind = 95;
pub const icalproperty_kind_ICAL_XLICMIMECONTENTTYPE_PROPERTY: icalproperty_kind = 96;
pub const icalproperty_kind_ICAL_XLICMIMEENCODING_PROPERTY: icalproperty_kind = 97;
pub const icalproperty_kind_ICAL_XLICMIMEFILENAME_PROPERTY: icalproperty_kind = 98;
pub const icalproperty_kind_ICAL_XLICMIMEOPTINFO_PROPERTY: icalproperty_kind = 99;
pub const icalproperty_kind_ICAL_NO_PROPERTY: icalproperty_kind = 100;
pub type icalproperty_kind = u32;
extern "C" {
    pub fn icalproperty_new_acceptresponse(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_acceptresponse(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_acceptresponse(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_acceptresponse(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_acknowledged(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_acknowledged(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_acknowledged(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_acknowledged(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_action(v: icalproperty_action) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_action(prop: *mut icalproperty, v: icalproperty_action);
}
extern "C" {
    pub fn icalproperty_get_action(prop: *const icalproperty) -> icalproperty_action;
}
extern "C" {
    pub fn icalproperty_vanew_action(v: icalproperty_action, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_allowconflict(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_allowconflict(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_allowconflict(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_allowconflict(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_attach(v: *mut icalattach) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_attach(prop: *mut icalproperty, v: *mut icalattach);
}
extern "C" {
    pub fn icalproperty_get_attach(prop: *const icalproperty) -> *mut icalattach;
}
extern "C" {
    pub fn icalproperty_vanew_attach(v: *mut icalattach, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_attendee(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_attendee(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_attendee(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_attendee(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_busytype(v: icalproperty_busytype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_busytype(prop: *mut icalproperty, v: icalproperty_busytype);
}
extern "C" {
    pub fn icalproperty_get_busytype(prop: *const icalproperty) -> icalproperty_busytype;
}
extern "C" {
    pub fn icalproperty_vanew_busytype(v: icalproperty_busytype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_calid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_calid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_calid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_calid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_calmaster(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_calmaster(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_calmaster(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_calmaster(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_calscale(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_calscale(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_calscale(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_calscale(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_capversion(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_capversion(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_capversion(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_capversion(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_carlevel(v: icalproperty_carlevel) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_carlevel(prop: *mut icalproperty, v: icalproperty_carlevel);
}
extern "C" {
    pub fn icalproperty_get_carlevel(prop: *const icalproperty) -> icalproperty_carlevel;
}
extern "C" {
    pub fn icalproperty_vanew_carlevel(v: icalproperty_carlevel, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_carid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_carid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_carid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_carid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_categories(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_categories(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_categories(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_categories(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_class(v: icalproperty_class) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_class(prop: *mut icalproperty, v: icalproperty_class);
}
extern "C" {
    pub fn icalproperty_get_class(prop: *const icalproperty) -> icalproperty_class;
}
extern "C" {
    pub fn icalproperty_vanew_class(v: icalproperty_class, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_cmd(v: icalproperty_cmd) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_cmd(prop: *mut icalproperty, v: icalproperty_cmd);
}
extern "C" {
    pub fn icalproperty_get_cmd(prop: *const icalproperty) -> icalproperty_cmd;
}
extern "C" {
    pub fn icalproperty_vanew_cmd(v: icalproperty_cmd, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_color(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_color(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_color(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_color(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_comment(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_comment(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_comment(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_comment(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_completed(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_completed(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_completed(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_completed(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_components(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_components(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_components(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_components(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_conference(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_conference(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_conference(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_conference(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_contact(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_contact(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_contact(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_contact(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_created(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_created(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_created(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_created(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_csid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_csid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_csid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_csid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_datemax(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_datemax(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_datemax(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_datemax(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_datemin(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_datemin(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_datemin(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_datemin(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_decreed(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_decreed(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_decreed(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_decreed(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_defaultcharset(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_defaultcharset(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_defaultcharset(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_defaultcharset(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_defaultlocale(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_defaultlocale(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_defaultlocale(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_defaultlocale(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_defaulttzid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_defaulttzid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_defaulttzid(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_defaulttzid(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_defaultvcars(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_defaultvcars(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_defaultvcars(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_defaultvcars(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_deny(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_deny(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_deny(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_deny(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_description(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_description(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_description(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_description(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_dtend(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_dtend(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_dtend(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_dtend(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_dtstamp(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_dtstamp(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_dtstamp(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_dtstamp(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_dtstart(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_dtstart(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_dtstart(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_dtstart(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_due(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_due(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_due(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_due(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_duration(v: icaldurationtype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_duration(prop: *mut icalproperty, v: icaldurationtype);
}
extern "C" {
    pub fn icalproperty_get_duration(prop: *const icalproperty) -> icaldurationtype;
}
extern "C" {
    pub fn icalproperty_vanew_duration(v: icaldurationtype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_estimatedduration(v: icaldurationtype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_estimatedduration(prop: *mut icalproperty, v: icaldurationtype);
}
extern "C" {
    pub fn icalproperty_get_estimatedduration(prop: *const icalproperty) -> icaldurationtype;
}
extern "C" {
    pub fn icalproperty_vanew_estimatedduration(v: icaldurationtype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_exdate(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_exdate(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_exdate(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_exdate(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_expand(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_expand(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_expand(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_expand(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_exrule(v: icalrecurrencetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_exrule(prop: *mut icalproperty, v: icalrecurrencetype);
}
extern "C" {
    pub fn icalproperty_get_exrule(prop: *const icalproperty) -> icalrecurrencetype;
}
extern "C" {
    pub fn icalproperty_vanew_exrule(v: icalrecurrencetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_freebusy(v: icalperiodtype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_freebusy(prop: *mut icalproperty, v: icalperiodtype);
}
extern "C" {
    pub fn icalproperty_get_freebusy(prop: *const icalproperty) -> icalperiodtype;
}
extern "C" {
    pub fn icalproperty_vanew_freebusy(v: icalperiodtype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_geo(v: icalgeotype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_geo(prop: *mut icalproperty, v: icalgeotype);
}
extern "C" {
    pub fn icalproperty_get_geo(prop: *const icalproperty) -> icalgeotype;
}
extern "C" {
    pub fn icalproperty_vanew_geo(v: icalgeotype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_grant(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_grant(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_grant(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_grant(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_image(v: *mut icalattach) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_image(prop: *mut icalproperty, v: *mut icalattach);
}
extern "C" {
    pub fn icalproperty_get_image(prop: *const icalproperty) -> *mut icalattach;
}
extern "C" {
    pub fn icalproperty_vanew_image(v: *mut icalattach, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_itipversion(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_itipversion(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_itipversion(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_itipversion(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_lastmodified(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_lastmodified(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_lastmodified(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_lastmodified(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_location(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_location(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_location(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_location(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_maxcomponentsize(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_maxcomponentsize(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_maxcomponentsize(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_maxcomponentsize(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_maxdate(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_maxdate(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_maxdate(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_maxdate(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_maxresults(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_maxresults(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_maxresults(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_maxresults(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_maxresultssize(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_maxresultssize(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_maxresultssize(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_maxresultssize(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_method(v: icalproperty_method) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_method(prop: *mut icalproperty, v: icalproperty_method);
}
extern "C" {
    pub fn icalproperty_get_method(prop: *const icalproperty) -> icalproperty_method;
}
extern "C" {
    pub fn icalproperty_vanew_method(v: icalproperty_method, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_mindate(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_mindate(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_mindate(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_mindate(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_multipart(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_multipart(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_multipart(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_multipart(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_name(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_name(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_name(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_name(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_organizer(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_organizer(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_organizer(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_organizer(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_owner(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_owner(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_owner(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_owner(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_patchdelete(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_patchdelete(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_patchdelete(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_patchdelete(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_patchorder(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_patchorder(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_patchorder(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_patchorder(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_patchparameter(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_patchparameter(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_patchparameter(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_patchparameter(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_patchtarget(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_patchtarget(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_patchtarget(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_patchtarget(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_patchversion(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_patchversion(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_patchversion(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_patchversion(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_percentcomplete(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_percentcomplete(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_percentcomplete(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_percentcomplete(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_permission(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_permission(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_permission(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_permission(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_pollcompletion(v: icalproperty_pollcompletion) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_pollcompletion(prop: *mut icalproperty, v: icalproperty_pollcompletion);
}
extern "C" {
    pub fn icalproperty_get_pollcompletion(
        prop: *const icalproperty,
    ) -> icalproperty_pollcompletion;
}
extern "C" {
    pub fn icalproperty_vanew_pollcompletion(
        v: icalproperty_pollcompletion,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_pollitemid(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_pollitemid(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_pollitemid(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_pollitemid(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_pollmode(v: icalproperty_pollmode) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_pollmode(prop: *mut icalproperty, v: icalproperty_pollmode);
}
extern "C" {
    pub fn icalproperty_get_pollmode(prop: *const icalproperty) -> icalproperty_pollmode;
}
extern "C" {
    pub fn icalproperty_vanew_pollmode(v: icalproperty_pollmode, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_pollproperties(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_pollproperties(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_pollproperties(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_pollproperties(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_pollwinner(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_pollwinner(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_pollwinner(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_pollwinner(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_priority(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_priority(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_priority(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_priority(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_prodid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_prodid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_prodid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_prodid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_query(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_query(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_query(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_query(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_querylevel(v: icalproperty_querylevel) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_querylevel(prop: *mut icalproperty, v: icalproperty_querylevel);
}
extern "C" {
    pub fn icalproperty_get_querylevel(prop: *const icalproperty) -> icalproperty_querylevel;
}
extern "C" {
    pub fn icalproperty_vanew_querylevel(v: icalproperty_querylevel, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_queryid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_queryid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_queryid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_queryid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_queryname(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_queryname(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_queryname(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_queryname(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_rdate(v: icaldatetimeperiodtype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_rdate(prop: *mut icalproperty, v: icaldatetimeperiodtype);
}
extern "C" {
    pub fn icalproperty_get_rdate(prop: *const icalproperty) -> icaldatetimeperiodtype;
}
extern "C" {
    pub fn icalproperty_vanew_rdate(v: icaldatetimeperiodtype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_recuraccepted(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_recuraccepted(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_recuraccepted(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_recuraccepted(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_recurexpand(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_recurexpand(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_recurexpand(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_recurexpand(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_recurlimit(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_recurlimit(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_recurlimit(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_recurlimit(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_recurrenceid(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_recurrenceid(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_recurrenceid(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_recurrenceid(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_refreshinterval(v: icaldurationtype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_refreshinterval(prop: *mut icalproperty, v: icaldurationtype);
}
extern "C" {
    pub fn icalproperty_get_refreshinterval(prop: *const icalproperty) -> icaldurationtype;
}
extern "C" {
    pub fn icalproperty_vanew_refreshinterval(v: icaldurationtype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_relatedto(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_relatedto(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_relatedto(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_relatedto(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_relcalid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_relcalid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_relcalid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_relcalid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_repeat(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_repeat(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_repeat(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_repeat(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_replyurl(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_replyurl(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_replyurl(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_replyurl(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_requeststatus(v: icalreqstattype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_requeststatus(prop: *mut icalproperty, v: icalreqstattype);
}
extern "C" {
    pub fn icalproperty_get_requeststatus(prop: *const icalproperty) -> icalreqstattype;
}
extern "C" {
    pub fn icalproperty_vanew_requeststatus(v: icalreqstattype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_resources(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_resources(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_resources(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_resources(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_response(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_response(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_response(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_response(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_restriction(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_restriction(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_restriction(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_restriction(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_rrule(v: icalrecurrencetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_rrule(prop: *mut icalproperty, v: icalrecurrencetype);
}
extern "C" {
    pub fn icalproperty_get_rrule(prop: *const icalproperty) -> icalrecurrencetype;
}
extern "C" {
    pub fn icalproperty_vanew_rrule(v: icalrecurrencetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_scope(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_scope(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_scope(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_scope(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_sequence(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_sequence(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_sequence(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_sequence(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_source(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_source(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_source(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_source(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_status(v: icalproperty_status) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_status(prop: *mut icalproperty, v: icalproperty_status);
}
extern "C" {
    pub fn icalproperty_get_status(prop: *const icalproperty) -> icalproperty_status;
}
extern "C" {
    pub fn icalproperty_vanew_status(v: icalproperty_status, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_storesexpanded(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_storesexpanded(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_storesexpanded(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_storesexpanded(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_summary(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_summary(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_summary(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_summary(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_target(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_target(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_target(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_target(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_taskmode(v: icalproperty_taskmode) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_taskmode(prop: *mut icalproperty, v: icalproperty_taskmode);
}
extern "C" {
    pub fn icalproperty_get_taskmode(prop: *const icalproperty) -> icalproperty_taskmode;
}
extern "C" {
    pub fn icalproperty_vanew_taskmode(v: icalproperty_taskmode, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_transp(v: icalproperty_transp) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_transp(prop: *mut icalproperty, v: icalproperty_transp);
}
extern "C" {
    pub fn icalproperty_get_transp(prop: *const icalproperty) -> icalproperty_transp;
}
extern "C" {
    pub fn icalproperty_vanew_transp(v: icalproperty_transp, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_trigger(v: icaltriggertype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_trigger(prop: *mut icalproperty, v: icaltriggertype);
}
extern "C" {
    pub fn icalproperty_get_trigger(prop: *const icalproperty) -> icaltriggertype;
}
extern "C" {
    pub fn icalproperty_vanew_trigger(v: icaltriggertype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_tzid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_tzid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzidaliasof(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzidaliasof(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_tzidaliasof(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_tzidaliasof(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzname(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzname(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_tzname(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_tzname(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzoffsetfrom(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzoffsetfrom(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_tzoffsetfrom(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_tzoffsetfrom(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzoffsetto(v: ::std::os::raw::c_int) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzoffsetto(prop: *mut icalproperty, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalproperty_get_tzoffsetto(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_vanew_tzoffsetto(v: ::std::os::raw::c_int, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzuntil(v: icaltimetype) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzuntil(prop: *mut icalproperty, v: icaltimetype);
}
extern "C" {
    pub fn icalproperty_get_tzuntil(prop: *const icalproperty) -> icaltimetype;
}
extern "C" {
    pub fn icalproperty_vanew_tzuntil(v: icaltimetype, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_tzurl(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_tzurl(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_tzurl(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_tzurl(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_uid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_uid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_uid(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_uid(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_url(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_url(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_url(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_url(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_version(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_version(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_version(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_version(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_voter(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_voter(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_voter(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_voter(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_x(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_x(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_x(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_x(v: *const ::std::os::raw::c_char, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicclass(v: icalproperty_xlicclass) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicclass(prop: *mut icalproperty, v: icalproperty_xlicclass);
}
extern "C" {
    pub fn icalproperty_get_xlicclass(prop: *const icalproperty) -> icalproperty_xlicclass;
}
extern "C" {
    pub fn icalproperty_vanew_xlicclass(v: icalproperty_xlicclass, ...) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicclustercount(v: *const ::std::os::raw::c_char)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicclustercount(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicclustercount(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicclustercount(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicerror(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicerror(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_xlicerror(prop: *const icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicerror(v: *const ::std::os::raw::c_char, ...)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimecharset(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimecharset(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicmimecharset(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimecharset(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimecid(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimecid(prop: *mut icalproperty, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_xlicmimecid(prop: *const icalproperty)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimecid(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimecontenttype(
        v: *const ::std::os::raw::c_char,
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimecontenttype(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicmimecontenttype(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimecontenttype(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimeencoding(v: *const ::std::os::raw::c_char)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimeencoding(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicmimeencoding(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimeencoding(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimefilename(v: *const ::std::os::raw::c_char)
        -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimefilename(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicmimefilename(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimefilename(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_xlicmimeoptinfo(v: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_xlicmimeoptinfo(
        prop: *mut icalproperty,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_xlicmimeoptinfo(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_vanew_xlicmimeoptinfo(
        v: *const ::std::os::raw::c_char,
        ...
    ) -> *mut icalproperty;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn icalproperty_new(kind: icalproperty_kind) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_impl(kind: icalproperty_kind) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_clone(prop: *mut icalproperty) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_new_from_string(str: *const ::std::os::raw::c_char) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_as_ical_string(prop: *mut icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_as_ical_string_r(prop: *mut icalproperty) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_free(prop: *mut icalproperty);
}
extern "C" {
    pub fn icalproperty_isa(property: *mut icalproperty) -> icalproperty_kind;
}
extern "C" {
    pub fn icalproperty_isa_property(
        property: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_add_parameters(prop: *mut icalproperty_impl, args: *mut __va_list_tag);
}
extern "C" {
    pub fn icalproperty_add_parameter(prop: *mut icalproperty, parameter: *mut icalparameter);
}
extern "C" {
    pub fn icalproperty_set_parameter(prop: *mut icalproperty, parameter: *mut icalparameter);
}
extern "C" {
    pub fn icalproperty_set_parameter_from_string(
        prop: *mut icalproperty,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_parameter_as_string(
        prop: *mut icalproperty,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_get_parameter_as_string_r(
        prop: *mut icalproperty,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_remove_parameter_by_kind(prop: *mut icalproperty, kind: icalparameter_kind);
}
extern "C" {
    pub fn icalproperty_remove_parameter_by_name(
        prop: *mut icalproperty,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_remove_parameter_by_ref(prop: *mut icalproperty, param: *mut icalparameter);
}
extern "C" {
    pub fn icalproperty_count_parameters(prop: *const icalproperty) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_get_first_parameter(
        prop: *mut icalproperty,
        kind: icalparameter_kind,
    ) -> *mut icalparameter;
}
extern "C" {
    pub fn icalproperty_get_next_parameter(
        prop: *mut icalproperty,
        kind: icalparameter_kind,
    ) -> *mut icalparameter;
}
extern "C" {
    pub fn icalproperty_set_value(prop: *mut icalproperty, value: *mut icalvalue);
}
extern "C" {
    pub fn icalproperty_set_value_from_string(
        prop: *mut icalproperty,
        value: *const ::std::os::raw::c_char,
        kind: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalproperty_get_value(prop: *const icalproperty) -> *mut icalvalue;
}
extern "C" {
    pub fn icalproperty_get_value_as_string(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_get_value_as_string_r(
        prop: *const icalproperty,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Sets the parent @p icalproperty for the specified @p icalvalue.
    pub fn icalvalue_set_parent(value: *mut icalvalue, property: *mut icalproperty);
}
extern "C" {
    /// Returns the parent @p icalproperty for the specified @p icalvalue.
    /// @since 3.0
    pub fn icalvalue_get_parent(value: *mut icalvalue) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_set_x_name(prop: *mut icalproperty, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalproperty_get_x_name(prop: *mut icalproperty) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the name of the property -- the type name converted to a
    ///  string, or the value of _get_x_name if the type is and X
    ///  property
    pub fn icalproperty_get_property_name(
        prop: *const icalproperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_get_property_name_r(
        prop: *const icalproperty,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparameter_value_to_value_kind(value: icalparameter_value) -> icalvalue_kind;
}
extern "C" {
    /// Sets the parent @p icalproperty for the specified @p icalparameter.
    /// @since 3.0
    pub fn icalparameter_set_parent(param: *mut icalparameter, property: *mut icalproperty);
}
extern "C" {
    /// Returns the parent @p icalproperty for the specified @p icalparameter.
    /// @since 3.0
    pub fn icalparameter_get_parent(param: *mut icalparameter) -> *mut icalproperty;
}
extern "C" {
    pub fn icalproperty_kind_to_value_kind(kind: icalproperty_kind) -> icalvalue_kind;
}
extern "C" {
    pub fn icalproperty_value_kind_to_kind(kind: icalvalue_kind) -> icalproperty_kind;
}
extern "C" {
    pub fn icalproperty_kind_to_string(kind: icalproperty_kind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_string_to_kind(string: *const ::std::os::raw::c_char) -> icalproperty_kind;
}
extern "C" {
    /// Check validity of a specific icalproperty_kind
    pub fn icalproperty_kind_is_valid(kind: icalproperty_kind) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_string_to_method(str: *const ::std::os::raw::c_char)
        -> icalproperty_method;
}
extern "C" {
    pub fn icalproperty_method_to_string(
        method: icalproperty_method,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_enum_to_string(e: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_enum_to_string_r(e: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_kind_and_string_to_enum(
        kind: ::std::os::raw::c_int,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalproperty_status_to_string(
        arg1: icalproperty_status,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalproperty_string_to_status(
        string: *const ::std::os::raw::c_char,
    ) -> icalproperty_status;
}
extern "C" {
    pub fn icalproperty_enum_belongs_to_property(
        kind: icalproperty_kind,
        e: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Normalizes (reorders and sorts the parameters) the specified @p icalproperty.
    /// @since 3.0
    pub fn icalproperty_normalize(prop: *mut icalproperty);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvl_list_t {
    _unused: [u8; 0],
}
pub type pvl_list = *mut pvl_list_t;
pub type pvl_elem = *mut pvl_elem_t;
/// This type is private. Always use pvl_elem instead. The struct would
/// not even appear in this header except to make code in the USE_MACROS
/// blocks work
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvl_elem_t {
    ///< Magic Identifier
    pub MAGIC: ::std::os::raw::c_int,
    ///< Pointer to data user is storing
    pub d: *mut ::std::os::raw::c_void,
    ///< Next element
    pub next: *mut pvl_elem_t,
    ///< Prior element
    pub prior: *mut pvl_elem_t,
}
#[test]
fn bindgen_test_layout_pvl_elem_t() {
    assert_eq!(
        ::std::mem::size_of::<pvl_elem_t>(),
        32usize,
        concat!("Size of: ", stringify!(pvl_elem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pvl_elem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pvl_elem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvl_elem_t>())).MAGIC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvl_elem_t),
            "::",
            stringify!(MAGIC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvl_elem_t>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pvl_elem_t),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvl_elem_t>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pvl_elem_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvl_elem_t>())).prior as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pvl_elem_t),
            "::",
            stringify!(prior)
        )
    );
}
extern "C" {
    pub fn pvl_new_element(
        d: *mut ::std::os::raw::c_void,
        next: pvl_elem,
        prior: pvl_elem,
    ) -> pvl_elem;
}
extern "C" {
    pub fn pvl_newlist() -> pvl_list;
}
extern "C" {
    pub fn pvl_free(arg1: pvl_list);
}
extern "C" {
    pub fn pvl_unshift(l: pvl_list, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pvl_shift(l: pvl_list) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pvl_head(arg1: pvl_list) -> pvl_elem;
}
extern "C" {
    pub fn pvl_push(l: pvl_list, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pvl_pop(l: pvl_list) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pvl_tail(arg1: pvl_list) -> pvl_elem;
}
pub type pvl_comparef = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void, b: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pvl_insert_ordered(l: pvl_list, f: pvl_comparef, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pvl_insert_after(l: pvl_list, e: pvl_elem, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pvl_insert_before(l: pvl_list, e: pvl_elem, d: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pvl_remove(arg1: pvl_list, arg2: pvl_elem) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pvl_clear(arg1: pvl_list);
}
extern "C" {
    pub fn pvl_count(arg1: pvl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvl_next(e: pvl_elem) -> pvl_elem;
}
extern "C" {
    pub fn pvl_prior(e: pvl_elem) -> pvl_elem;
}
extern "C" {
    pub fn pvl_data(arg1: pvl_elem) -> *mut ::std::os::raw::c_void;
}
pub type pvl_findf = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void, b: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pvl_find(l: pvl_list, f: pvl_findf, v: *mut ::std::os::raw::c_void) -> pvl_elem;
}
extern "C" {
    pub fn pvl_find_next(l: pvl_list, f: pvl_findf, v: *mut ::std::os::raw::c_void) -> pvl_elem;
}
/// Pass each element in the list to a function
/// a is list elem, b is other data
pub type pvl_applyf = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void, b: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn pvl_apply(l: pvl_list, f: pvl_applyf, v: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalcomponent_impl {
    _unused: [u8; 0],
}
pub type icalcomponent = icalcomponent_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalcompiter {
    pub kind: icalcomponent_kind,
    pub iter: pvl_elem,
}
#[test]
fn bindgen_test_layout_icalcompiter() {
    assert_eq!(
        ::std::mem::size_of::<icalcompiter>(),
        16usize,
        concat!("Size of: ", stringify!(icalcompiter))
    );
    assert_eq!(
        ::std::mem::align_of::<icalcompiter>(),
        8usize,
        concat!("Alignment of ", stringify!(icalcompiter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalcompiter>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icalcompiter),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icalcompiter>())).iter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(icalcompiter),
            "::",
            stringify!(iter)
        )
    );
}
extern "C" {
    pub fn icalcomponent_new(kind: icalcomponent_kind) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_clone(component: *mut icalcomponent) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_from_string(str: *const ::std::os::raw::c_char) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_vanew(kind: icalcomponent_kind, ...) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_x(x_name: *const ::std::os::raw::c_char) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_free(component: *mut icalcomponent);
}
extern "C" {
    pub fn icalcomponent_as_ical_string(
        component: *mut icalcomponent,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_as_ical_string_r(
        component: *mut icalcomponent,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_is_valid(component: *mut icalcomponent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalcomponent_isa(component: *const icalcomponent) -> icalcomponent_kind;
}
extern "C" {
    pub fn icalcomponent_isa_component(
        component: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalcomponent_add_property(component: *mut icalcomponent, property: *mut icalproperty);
}
extern "C" {
    pub fn icalcomponent_remove_property(
        component: *mut icalcomponent,
        property: *mut icalproperty,
    );
}
extern "C" {
    pub fn icalcomponent_count_properties(
        component: *mut icalcomponent,
        kind: icalproperty_kind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets the parent icalcomponent for the specified icalproperty @p property.
    /// @since 3.0
    pub fn icalproperty_set_parent(property: *mut icalproperty, component: *mut icalcomponent);
}
extern "C" {
    /// Returns the parent @p icalcomponent for the specified @p icalproperty.
    pub fn icalproperty_get_parent(property: *const icalproperty) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_get_current_property(component: *mut icalcomponent) -> *mut icalproperty;
}
extern "C" {
    pub fn icalcomponent_get_first_property(
        component: *mut icalcomponent,
        kind: icalproperty_kind,
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalcomponent_get_next_property(
        component: *mut icalcomponent,
        kind: icalproperty_kind,
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icalcomponent_get_inner(comp: *mut icalcomponent) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_add_component(parent: *mut icalcomponent, child: *mut icalcomponent);
}
extern "C" {
    pub fn icalcomponent_remove_component(parent: *mut icalcomponent, child: *mut icalcomponent);
}
extern "C" {
    pub fn icalcomponent_count_components(
        component: *mut icalcomponent,
        kind: icalcomponent_kind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///This takes 2 VCALENDAR components and merges the second one into the first,
    ///resolving any problems with conflicting TZIDs. comp_to_merge will no
    ///longer exist after calling this function.
    pub fn icalcomponent_merge_component(
        comp: *mut icalcomponent,
        comp_to_merge: *mut icalcomponent,
    );
}
extern "C" {
    pub fn icalcomponent_get_current_component(component: *mut icalcomponent)
        -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_get_first_component(
        component: *mut icalcomponent,
        kind: icalcomponent_kind,
    ) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_get_next_component(
        component: *mut icalcomponent,
        kind: icalcomponent_kind,
    ) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_begin_component(
        component: *mut icalcomponent,
        kind: icalcomponent_kind,
    ) -> icalcompiter;
}
extern "C" {
    pub fn icalcomponent_end_component(
        component: *mut icalcomponent,
        kind: icalcomponent_kind,
    ) -> icalcompiter;
}
extern "C" {
    pub fn icalcompiter_next(i: *mut icalcompiter) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcompiter_prior(i: *mut icalcompiter) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcompiter_deref(i: *mut icalcompiter) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_check_restrictions(comp: *mut icalcomponent) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Count embedded errors.
    pub fn icalcomponent_count_errors(component: *mut icalcomponent) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove all X-LIC-ERROR properties
    pub fn icalcomponent_strip_errors(component: *mut icalcomponent);
}
extern "C" {
    /// Convert some X-LIC-ERROR properties into RETURN-STATUS properties
    pub fn icalcomponent_convert_errors(component: *mut icalcomponent);
}
extern "C" {
    pub fn icalcomponent_get_parent(component: *mut icalcomponent) -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_set_parent(component: *mut icalcomponent, parent: *mut icalcomponent);
}
extern "C" {
    pub fn icalcomponent_kind_is_valid(kind: icalcomponent_kind) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalcomponent_string_to_kind(
        string: *const ::std::os::raw::c_char,
    ) -> icalcomponent_kind;
}
extern "C" {
    pub fn icalcomponent_kind_to_string(kind: icalcomponent_kind) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// For VCOMPONENT: Return a reference to the first VEVENT, VTODO or
    ///VJOURNAL
    pub fn icalcomponent_get_first_real_component(c: *mut icalcomponent) -> *mut icalcomponent;
}
extern "C" {
    /// For VEVENT, VTODO, VJOURNAL and VTIMEZONE: report the start and end
    ///times of an event in UTC
    pub fn icalcomponent_get_span(comp: *mut icalcomponent) -> icaltime_span;
}
extern "C" {
    /// Convenience routines
    pub fn icalcomponent_set_dtstart(comp: *mut icalcomponent, v: icaltimetype);
}
extern "C" {
    pub fn icalcomponent_get_dtstart(comp: *mut icalcomponent) -> icaltimetype;
}
extern "C" {
    pub fn icalcomponent_get_dtend(comp: *mut icalcomponent) -> icaltimetype;
}
extern "C" {
    pub fn icalcomponent_set_dtend(comp: *mut icalcomponent, v: icaltimetype);
}
extern "C" {
    pub fn icalcomponent_get_due(comp: *mut icalcomponent) -> icaltimetype;
}
extern "C" {
    pub fn icalcomponent_set_due(comp: *mut icalcomponent, v: icaltimetype);
}
extern "C" {
    pub fn icalcomponent_set_duration(comp: *mut icalcomponent, v: icaldurationtype);
}
extern "C" {
    pub fn icalcomponent_get_duration(comp: *mut icalcomponent) -> icaldurationtype;
}
extern "C" {
    pub fn icalcomponent_set_method(comp: *mut icalcomponent, method: icalproperty_method);
}
extern "C" {
    pub fn icalcomponent_get_method(comp: *mut icalcomponent) -> icalproperty_method;
}
extern "C" {
    pub fn icalcomponent_get_dtstamp(comp: *mut icalcomponent) -> icaltimetype;
}
extern "C" {
    pub fn icalcomponent_set_dtstamp(comp: *mut icalcomponent, v: icaltimetype);
}
extern "C" {
    pub fn icalcomponent_set_summary(comp: *mut icalcomponent, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalcomponent_get_summary(comp: *mut icalcomponent) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_comment(comp: *mut icalcomponent, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalcomponent_get_comment(comp: *mut icalcomponent) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_uid(comp: *mut icalcomponent, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalcomponent_get_uid(comp: *mut icalcomponent) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_relcalid(comp: *mut icalcomponent, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalcomponent_get_relcalid(comp: *mut icalcomponent) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_recurrenceid(comp: *mut icalcomponent, v: icaltimetype);
}
extern "C" {
    pub fn icalcomponent_get_recurrenceid(comp: *mut icalcomponent) -> icaltimetype;
}
extern "C" {
    pub fn icalcomponent_set_description(
        comp: *mut icalcomponent,
        v: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn icalcomponent_get_description(comp: *mut icalcomponent)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_location(comp: *mut icalcomponent, v: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn icalcomponent_get_location(comp: *mut icalcomponent) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalcomponent_set_sequence(comp: *mut icalcomponent, v: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icalcomponent_get_sequence(comp: *mut icalcomponent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalcomponent_set_status(comp: *mut icalcomponent, v: icalproperty_status);
}
extern "C" {
    pub fn icalcomponent_get_status(comp: *mut icalcomponent) -> icalproperty_status;
}
extern "C" {
    /// Calls the given function for each TZID parameter found in the
    ///component, and any subcomponents.
    pub fn icalcomponent_foreach_tzid(
        comp: *mut icalcomponent,
        callback: ::std::option::Option<
            unsafe extern "C" fn(param: *mut icalparameter, data: *mut ::std::os::raw::c_void),
        >,
        callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Returns the icaltimezone in the component corresponding to the
    ///TZID, or NULL if it can't be found.
    pub fn icalcomponent_get_timezone(
        comp: *mut icalcomponent,
        tzid: *const ::std::os::raw::c_char,
    ) -> *mut icaltimezone;
}
extern "C" {
    pub fn icalproperty_recurrence_is_excluded(
        comp: *mut icalcomponent,
        dtstart: *mut icaltimetype,
        recurtime: *mut icaltimetype,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalcomponent_foreach_recurrence(
        comp: *mut icalcomponent,
        start: icaltimetype,
        end: icaltimetype,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                comp: *mut icalcomponent,
                span: *mut icaltime_span,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Normalizes (reorders and sorts the properties) the specified icalcomponent @p comp.
    /// @since 3.0
    pub fn icalcomponent_normalize(comp: *mut icalcomponent);
}
extern "C" {
    /// Type Specific routines
    pub fn icalcomponent_new_vcalendar() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vevent() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vtodo() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vjournal() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_valarm() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vfreebusy() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vtimezone() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_xstandard() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_xdaylight() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vagenda() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vquery() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vavailability() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_xavailable() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vpoll() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vvoter() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_xvote() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_vpatch() -> *mut icalcomponent;
}
extern "C" {
    pub fn icalcomponent_new_xpatch() -> *mut icalcomponent;
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    /// Creates a new icaltimezone.
    pub fn icaltimezone_new() -> *mut icaltimezone;
}
extern "C" {
    pub fn icaltimezone_copy(originalzone: *mut icaltimezone) -> *mut icaltimezone;
}
extern "C" {
    /// Frees all memory used for the icaltimezone. Set free_struct to free the
    ///icaltimezone struct as well.
    pub fn icaltimezone_free(zone: *mut icaltimezone, free_struct: ::std::os::raw::c_int);
}
extern "C" {
    /// Sets the prefix to be used for tzid's generated from system tzdata.
    ///Must be globally unique (such as a domain name owned by the developer
    ///of the calling application), and begin and end with forward slashes.
    ///Do not change or de-allocate the string buffer after calling this.
    pub fn icaltimezone_set_tzid_prefix(new_prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Free any builtin timezone information
    pub fn icaltimezone_free_builtin_timezones();
}
extern "C" {
    /// Returns the array of builtin icaltimezones.
    pub fn icaltimezone_get_builtin_timezones() -> *mut icalarray;
}
extern "C" {
    /// Returns a single builtin timezone, given its Olson city name.
    pub fn icaltimezone_get_builtin_timezone(
        location: *const ::std::os::raw::c_char,
    ) -> *mut icaltimezone;
}
extern "C" {
    /// Returns a single builtin timezone, given its offset.
    pub fn icaltimezone_get_builtin_timezone_from_offset(
        offset: ::std::os::raw::c_int,
        tzname: *const ::std::os::raw::c_char,
    ) -> *mut icaltimezone;
}
extern "C" {
    /// Returns a single builtin timezone, given its TZID.
    pub fn icaltimezone_get_builtin_timezone_from_tzid(
        tzid: *const ::std::os::raw::c_char,
    ) -> *mut icaltimezone;
}
extern "C" {
    /// Returns the UTC timezone.
    pub fn icaltimezone_get_utc_timezone() -> *mut icaltimezone;
}
extern "C" {
    /// Returns the TZID of a timezone.
    pub fn icaltimezone_get_tzid(zone: *mut icaltimezone) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Returns the city name of a timezone.
    pub fn icaltimezone_get_location(zone: *mut icaltimezone) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Returns the TZNAME properties used in the latest STANDARD and DAYLIGHT
    ///components. If they are the same it will return just one, e.g. "LMT".
    ///If they are different it will format them like "EST/EDT". Note that this
    ///may also return NULL.
    pub fn icaltimezone_get_tznames(zone: *mut icaltimezone) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Returns the latitude of a builtin timezone.
    pub fn icaltimezone_get_latitude(zone: *mut icaltimezone) -> f64;
}
extern "C" {
    /// Returns the longitude of a builtin timezone.
    pub fn icaltimezone_get_longitude(zone: *mut icaltimezone) -> f64;
}
extern "C" {
    /// Returns the VTIMEZONE component of a timezone.
    pub fn icaltimezone_get_component(zone: *mut icaltimezone) -> *mut icalcomponent;
}
extern "C" {
    /// Sets the VTIMEZONE component of an icaltimezone, initializing the tzid,
    ///location & tzname fields. It returns 1 on success or 0 on failure, i.e.
    ///no TZID was found.
    pub fn icaltimezone_set_component(
        zone: *mut icaltimezone,
        comp: *mut icalcomponent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icaltimezone_get_display_name(zone: *mut icaltimezone) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @par Converting times between timezones.
    pub fn icaltimezone_convert_time(
        tt: *mut icaltimetype,
        from_zone: *mut icaltimezone,
        to_zone: *mut icaltimezone,
    );
}
extern "C" {
    /// Calculates the UTC offset of a given local time in the given
    ///timezone.  It is the number of seconds to add to UTC to get local
    ///time.  The is_daylight flag is set to 1 if the time is in
    ///daylight-savings time.
    pub fn icaltimezone_get_utc_offset(
        zone: *mut icaltimezone,
        tt: *mut icaltimetype,
        is_daylight: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Calculates the UTC offset of a given UTC time in the given
    ///timezone.  It is the number of seconds to add to UTC to get local
    ///time.  The is_daylight flag is set to 1 if the time is in
    ///daylight-savings time.
    pub fn icaltimezone_get_utc_offset_of_utc_time(
        zone: *mut icaltimezone,
        tt: *mut icaltimetype,
        is_daylight: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icaltimezone_array_new() -> *mut icalarray;
}
extern "C" {
    pub fn icaltimezone_array_append_from_vtimezone(
        timezones: *mut icalarray,
        child: *mut icalcomponent,
    );
}
extern "C" {
    pub fn icaltimezone_array_free(timezones: *mut icalarray);
}
extern "C" {
    pub fn icaltimezone_expand_vtimezone(
        comp: *mut icalcomponent,
        end_year: ::std::os::raw::c_int,
        changes: *mut icalarray,
    );
}
extern "C" {
    pub fn icaltimezone_get_location_from_vtimezone(
        component: *mut icalcomponent,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icaltimezone_get_tznames_from_vtimezone(
        component: *mut icalcomponent,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Set the directory to look for the zonefiles
    pub fn set_zone_directory(path: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Free memory dedicated to the zonefile directory
    pub fn free_zone_directory();
}
extern "C" {
    pub fn icaltimezone_release_zone_tab();
}
extern "C" {
    pub fn icaltimezone_set_builtin_tzdata(set: ::std::os::raw::c_int);
}
extern "C" {
    pub fn icaltimezone_get_builtin_tzdata() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dumps information about changes in the timezone up to and including
    ///max_year.
    pub fn icaltimezone_dump_changes(
        zone: *mut icaltimezone,
        max_year: ::std::os::raw::c_int,
        fp: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icaltimezone_tzid_prefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icaltzutil_get_zone_directory() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icaltzutil_fetch_timezone(location: *const ::std::os::raw::c_char)
        -> *mut icalcomponent;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icalparser_impl {
    _unused: [u8; 0],
}
/// @struct icalparser_impl
/// @typedef icalparser
/// @private
///
/// Implementation of the icalparser struct, which holds the
/// state for the current parsing operation.
pub type icalparser = icalparser_impl;
/// An error occurred while parsing.
pub const icalparser_state_ICALPARSER_ERROR: icalparser_state = 0;
/// Parsing was successful.
pub const icalparser_state_ICALPARSER_SUCCESS: icalparser_state = 1;
/// Currently parsing the begin of a component
pub const icalparser_state_ICALPARSER_BEGIN_COMP: icalparser_state = 2;
/// Currently parsing the end of the component
pub const icalparser_state_ICALPARSER_END_COMP: icalparser_state = 3;
/// Parsing is currently in progress
pub const icalparser_state_ICALPARSER_IN_PROGRESS: icalparser_state = 4;
/// @enum icalparser_state
/// @typedef icalparser_state
/// @brief Represents the current state of the parser
pub type icalparser_state = u32;
pub type icalparser_line_gen_func = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut ::std::os::raw::c_char,
        size: usize,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    /// @brief Creates a new ::icalparser.
    /// @return An ::icalparser object
    ///
    /// @par Error handling
    /// On error, it returns `NULL` and sets ::icalerrno to
    /// ::ICAL_NEWFAILED_ERROR.
    ///
    /// @par Ownership
    /// All ::icalparser objects created with this function need to be
    /// freed using the icalparser_free() function.
    ///
    /// ### Usage
    /// ```c
    /// // create new parser
    /// icalparser *parser = icalparser_new();
    ///
    /// // do something with it...
    ///
    /// // free parser
    /// icalparser_free(parser);
    /// ```
    pub fn icalparser_new() -> *mut icalparser;
}
extern "C" {
    /// @brief Adds a single line to be parsed by the ::icalparser.
    /// @param parser The parser to use
    /// @param str A string representing a single line of RFC5545-formatted iCalendar data
    /// @return When this was the last line of the component to be parsed,
    ///  it returns the icalcomponent, otherwise it returns `NULL`.
    /// @sa icalparser_parse()
    ///
    /// @par Error handling
    /// -   If @a parser is `NULL`, it returns `NULL` and sets ::icalerrno to
    ///     ::ICAL_BADARG_ERROR.
    /// -   If @a line is empty, if returns `NULL`
    /// -   If @a line is `NULL`, it returns `NULL` and sets the @a parser's ::icalparser_state to
    ///     ::ICALPARSER_ERROR.
    /// -   For errors during parsing, the functions can set the ::icalparser_state to
    ///     ::ICALPARSER_ERROR and/or return components of the type ::ICAL_XLICINVALID_COMPONENT,
    ///     or components with properties of the type ::ICAL_XLICERROR_PROPERTY.
    ///
    /// @par Ownership
    /// Ownership of the @a str is transferred to libical upon calling this
    /// method. The returned ::icalcomponent is owned by the caller and needs
    /// to be `free()`d with the appropriate method after it's no longer needed.
    ///
    /// ### Example
    /// ```c
    /// char* read_stream(char *s, size_t size, void *d)
    /// {
    ///return fgets(s, (int)size, (FILE*)d);
    /// }
    ///
    /// void parse()
    /// {
    ///     char* line;
    ///     FILE* stream;
    ///     icalcomponent *component;
    ///
    ///     icalparser *parser = icalparser_new();
    ///     stream = fopen(argv[1],"r");
    ///
    ///     icalparser_set_gen_data(parser, stream);
    ///
    ///     do{
    ///         // get a single content line
    ///         line = icalparser_get_line(parser, read_stream);
    ///
    ///         // add that line to the parser
    ///         c = icalparser_add_line(parser,line);
    ///
    ///         // once we parsed a component, print it
    ///         if (c != 0) {
    ///             printf("%s", icalcomponent_as_ical_string(c));
    ///             icalcomponent_free(c);
    ///         }
    ///     } while (line != 0);
    ///
    ///     icalparser_free(parser);
    /// }
    /// ```
    pub fn icalparser_add_line(
        parser: *mut icalparser,
        str: *mut ::std::os::raw::c_char,
    ) -> *mut icalcomponent;
}
extern "C" {
    /// @brief Cleans out an ::icalparser and returns whatever it has parsed so far.
    /// @param parser The ::icalparser to clean
    /// @return The parsed ::icalcomponent
    ///
    /// @par Error handling
    /// If @a parser is `NULL`, it returns `NULL` and sets ::icalerrno to
    /// ::ICAL_BADARG_ERROR. For parsing errors, it inserts an `X-LIC-ERROR`
    /// property into the affected components.
    ///
    /// @par Ownership
    /// The returned ::icalcomponent is property of the caller and needs to be
    /// free'd with icalcomponent_free() after use.
    ///
    /// This will parse components even if it hasn't encountered a proper
    /// `END` tag for it yet and return them, as well as clearing any intermediate
    /// state resulting from being in the middle of parsing something so the
    /// parser can be used to parse something new.
    pub fn icalparser_clean(parser: *mut icalparser) -> *mut icalcomponent;
}
extern "C" {
    /// @brief Returns current state of the icalparser
    /// @param parser The (valid, non-`NULL`) parser object
    /// @return The current state of the icalparser, as an ::icalparser_state
    ///
    /// ### Example
    /// ```c
    /// icalparser *parser = icalparser_new();
    ///
    /// // use icalparser...
    ///
    /// if(icalparser_get_state(parser) == ICALPARSER_ERROR) {
    ///     // handle error
    /// } else {
    ///     // ...
    /// }
    /// ```
    ///
    /// icalparser_free(parser);
    pub fn icalparser_get_state(parser: *mut icalparser) -> icalparser_state;
}
extern "C" {
    /// @brief Frees an ::icalparser object.
    /// @param parser The ::icalparser to be freed.
    ///
    /// ### Example
    /// ```c
    /// icalparser *parser = icalparser_new();
    ///
    /// // use parser ...
    ///
    /// icalparser_free(parser);
    /// ```
    pub fn icalparser_free(parser: *mut icalparser);
}
extern "C" {
    /// @brief Message oriented parsing.
    /// @param parser The parser to use
    /// @param line_gen_func A function that returns one content line per invocation
    /// @return The parsed icalcomponent
    /// @sa icalparser_parse_string()
    ///
    /// Reads an icalcomponent using the supplied @a line_gen_func, returning the parsed
    /// component (or `NULL` on error).
    ///
    /// @par Error handling
    /// -   If @a parser is `NULL`, it returns `NULL` and sets ::icalerrno to ::ICAL_BADARG_ERROR.
    /// -   If data read by @a line_gen_func is empty, if returns `NULL`
    /// -   If data read by @a line_gen_func is `NULL`, it returns `NULL`
    ///     and sets the @a parser's ::icalparser_state to ::ICALPARSER_ERROR.
    /// -   For errors during parsing, the functions can set the ::icalparser_state to
    ///     ::ICALPARSER_ERROR and/or return components of the type ::ICAL_XLICINVALID_COMPONENT,
    ///     or components with properties of the type ::ICAL_XLICERROR_PROPERTY.
    ///
    /// @par Ownership
    /// The returned ::icalcomponent is owned by the caller of the function, and
    /// needs to be `free()`d with the appropriate method when no longer needed.
    ///
    /// ### Example
    /// ```c
    /// char* read_stream(char *s, size_t size, void *d)
    /// {
    ///return fgets(s, (int)size, (FILE*)d);
    /// }
    ///
    /// void parse()
    /// {
    ///     char* line;
    ///     FILE* stream;
    ///     icalcomponent *component;
    ///
    ///     icalparser *parser = icalparser_new();
    ///     stream = fopen(argv[1],"r");
    ///
    ///     icalparser_set_gen_data(parser, stream);
    ///
    ///     // use the parse method to parse the input data
    ///     component = icalparser_parse(parser, read_stream);
    ///
    ///     // once we parsed a component, print it
    ///     printf("%s", icalcomponent_as_ical_string(c));
    ///     icalcomponent_free(c);
    ///
    ///     icalparser_free(parser);
    /// }
    /// ```
    pub fn icalparser_parse(
        parser: *mut icalparser,
        line_gen_func: icalparser_line_gen_func,
    ) -> *mut icalcomponent;
}
extern "C" {
    /// @brief Sets the data that icalparser_parse will give to the line_gen_func
    /// as the parameter 'd'.
    /// @param parser The icalparser this applies to
    /// @param data The pointer which will be passed to the line_gen_func as argument `d`
    ///
    /// If you use any of the icalparser_parser() or icalparser_get_line() functions,
    /// the @a line_gen_func that they expect has a third `void* d` argument. This function
    /// sets what will be passed to your @a line_gen_function as such argument.
    pub fn icalparser_set_gen_data(parser: *mut icalparser, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Parse a string and return the parsed ::icalcomponent.
    /// @param str The iCal formatted data to be parsed
    /// @return An ::icalcomponent representing the iCalendar
    ///
    /// @par Error handling
    /// On error, returns `NULL` and sets ::icalerrno
    ///
    /// @par Ownership
    /// The returned ::icalcomponent is owned by the caller of the function, and
    /// needs to be free'd with the appropriate functions after use.
    ///
    /// ### Example
    /// ```c
    /// char *ical_string;
    ///
    /// // parse ical_string
    /// icalcomponent *component = icalparser_parse_string(ical_string);
    ///
    /// if(!icalerrno || component == NULL) {
    ///     // use component ...
    /// }
    ///
    /// // release component
    /// icalcomponent_free(component);
    /// ```
    pub fn icalparser_parse_string(str: *const ::std::os::raw::c_char) -> *mut icalcomponent;
}
extern "C" {
    /// @brief Given a line generator function, return a single iCal content line.
    /// @return Aa pointer to a single line of data or `NULL` if it reached
    ///  end of file reading from the @a line_gen_func. Note that the pointer
    ///  returned is owned by libical and must not be `free()`d by the user.
    /// @param parser The parser object to use
    /// @param line_gen_func The function to use for reading data
    ///
    /// This function uses the supplied @a line_gen_func to read data in,
    /// until it has read a full line, and returns the full line.
    /// To supply arbitrary data (as the parameter @a d) to your @a line_gen_func,
    /// call icalparser_set_gen_data().
    pub fn icalparser_get_line(
        parser: *mut icalparser,
        line_gen_func: icalparser_line_gen_func,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icalparser_string_line_generator(
        out: *mut ::std::os::raw::c_char,
        buf_size: usize,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Creates a new temporary buffer on the ring and returns it.
    /// @param size How big (in bytes) the buffer should be
    /// @return A pointer to the newly created buffer on the ring
    ///
    /// Creates a temporary buffer on the ring. Regardless of what @a size you
    /// specify, the buffer will always be at least ::MIN_BUFFER_SIZE big, and it
    /// will be zeroed out.
    ///
    /// @par Error handling
    /// If there is a problem allocating memory for the buffer, it sets ::icalerrno
    /// to ::ICAL_NEWFAILED_ERROR and returns `NULL`.
    ///
    /// @par Ownership
    /// The returned buffer is owned by icalmemory. It must not be freed by the
    /// caller and the returned memory will be automatically reclaimed as more items
    /// are added to the ring buffer.
    ///
    /// ### Usage
    /// ```c
    /// char *str = icalmemory_tmp_buffer(256);
    /// strcpy(str, "some data");
    ///
    /// // use str
    /// ```
    pub fn icalmemory_tmp_buffer(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Creates a copy of the given string, stored on the ring buffer, and
    ///  returns it.
    /// @param str The string to copy
    /// @return A copy of @a str, which has been placed on the ring buffer for
    ///  automatic reclamation.
    ///
    /// @par Error handling
    /// The passed string @a str must not be `NULL`, otherwise a segfault might
    /// ensue, since the routine calls `strlen()` on it.
    ///
    /// @par Ownership
    /// The returned string is owned by icalmemory. It must not be freed by the
    /// caller, and it will be automatically reclaimed as more items are added to the
    /// buffer.
    ///
    /// ### Usage
    /// ```c
    /// const char *str = "Example string";
    /// char *tmp_copy = icalmemory_tmp_copy(str);
    /// ```
    pub fn icalmemory_tmp_copy(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Add an externally allocated buffer to the ring.
    /// @param buf The externally allocated buffer to add to the ring
    ///
    /// Adds an externally allocated buffer to the ring. This ensures that libical
    /// will `free()` the buffer automatically, either after ::BUFFER_RING_SIZE other
    /// buffers have been created or added, or after ::icalmemory_free_ring() has
    /// been called.
    ///
    /// @par Error handling
    /// No error is raised if @a buf is `NULL`.
    ///
    /// @par Ownership
    /// After adding @a buf to the ring, it becomes owned by icalmemory and must not
    /// be `free()`d manually anymore, it leads to a double-`free()` when icalmemory
    /// reclaims the memory.
    ///
    /// ### Usage
    /// ```c
    /// char *buf = calloc(256, sizeof(char));
    ///
    /// icalmemory_add_tmp_buffer(buf);
    /// ```
    pub fn icalmemory_add_tmp_buffer(buf: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Free all memory used in the ring
    ///
    /// Frees all memory used in the ring. Depending on if ::HAVE_PTHREAD is set or
    /// not, the ring buffer is allocated on a per-thread basis, meaning that if all
    /// rings are to be released, it must be called once in every thread.
    ///
    /// ### Usage
    /// ``` c
    /// void *buf = icalmemory_tmp_buffer(256);
    ///
    /// // use buf
    ///
    /// // release buf and all other memory in the ring buffer
    /// icalmemory_free_ring();
    /// ```
    pub fn icalmemory_free_ring();
}
extern "C" {
    /// @brief Creates new buffer with the specified size.
    /// @param size The size of the buffer that is to be created.
    /// @return A pointer to the newly-created buffer.
    /// @sa icalmemory_free_buffer()
    ///
    /// @par Error handling
    /// If there is a problem allocating memory, it sets ::icalerrno to
    /// ::ICAL_NEWFAILED_ERROR and returns `NULL`.
    ///
    /// @par Ownership
    /// Buffers created with this method are owned by the caller. The must be
    /// released with the appropriate icalmemory_free_buffer() method.
    ///
    /// This creates a new (non-temporary) buffer of the specified @a size. All
    /// buffers returned by this method are zeroed-out.
    ///
    /// ### Usage
    /// ```c
    /// // create buffer
    /// char *buffer = icalmemory_new_buffer(50);
    ///
    /// // fill buffer
    /// strcpy(buffer, "some data");
    ///
    /// // release buffer
    /// icalmemory_free_buffer(buffer);
    /// ```
    pub fn icalmemory_new_buffer(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Resizes a buffer created with icalmemory_new_buffer().
    /// @param buf The buffer to be resized.
    /// @param size The new size of the buffer.
    /// @return The new, resized buffer.
    /// @sa icalmemory_new_buffer()
    /// @warning This method may not be used for temporary buffers (buffers allocated
    /// with icalmemory_tmp_buffer() and related functions)!
    ///
    /// @par Error handling
    /// If there is a problem while reallocating the buffer, the method sets
    /// ::icalerrno to ::ICAL_NEWFAILED_ERROR and returns `NULL`.
    ///
    /// @par Ownership
    /// The returned buffer is owned by the caller and needs to be released with the
    /// appropriate icalmemory_free_buffer() method. The old buffer, @a buf, can not
    /// be used anymore after calling this method.
    ///
    /// ### Usage
    /// ```c
    /// // create new buffer
    /// char *buffer = icalmemory_new_buffer(10);
    ///
    /// // fill buffer
    /// strcpy(buffer, "some data");
    ///
    /// // expand buffer
    /// buffer = icalmemory_resize_buffer(buffer, 20);
    ///
    /// // fill with more data
    /// strcpy(buffer, "a lot more data");
    ///
    /// // release
    /// icalmemory_free_buffer(buffer);
    /// ```
    pub fn icalmemory_resize_buffer(
        buf: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// @brief Releases a buffer
    /// @param buf The buffer to release
    /// @sa icalmemory_new_buffer()
    ///
    /// Releases the memory of the buffer.
    pub fn icalmemory_free_buffer(buf: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// @brief Append a string to a buffer.
    /// @param buf The buffer to append the string to.
    /// @param pos The position to append the string at.
    /// @param buf_size The size of the buffer (will be changed if buffer is
    /// reallocated)
    /// @param string The string to append to the buffer.
    /// @warning This method may not be used for temporary buffers (buffers allocated
    ///  with icalmemory_tmp_buffer() and related functions)!
    ///
    /// @par Error handling
    /// Sets ::icalerrno to ::ICAL_BADARG_ERROR if @a buf, `*buf`, @a pos, `* pos`,
    /// @a buf_size or @a string are `NULL`.
    ///
    /// This method will copy the string @a string to the buffer @a buf starting at
    /// position @a pos, reallocing @a buf if it is too small. @a buf_size is the
    /// size of @a buf and will be changed if @a buf is reallocated. @a pos will
    /// point to the last byte of the new string in @a buf, usually a `'\0'`
    ///
    /// ### Example
    /// ```c
    /// // creates a new buffer
    /// int buffer_len = 15;
    /// char *buffer = icalmemory_new_buffer(buffer_len);
    /// strcpy(buffer, "My name is: ");
    ///
    /// // append a string to the buffer
    /// int buffer_end = strlen(buffer);
    /// char *buffer_end_pos = buffer[buffer_str_end];
    /// icalmemory_append_string(&buffer, &buffer_end_pos, &buffer_len, "John Doe");
    ///
    /// // print string
    /// printf("%s\n", buffer);
    ///
    /// // release memory
    /// icalmemory_free_buffer(buffer);
    /// ```
    pub fn icalmemory_append_string(
        buf: *mut *mut ::std::os::raw::c_char,
        pos: *mut *mut ::std::os::raw::c_char,
        buf_size: *mut usize,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Append a character to a buffer.
    /// @param buf The buffer to append the character to.
    /// @param pos The position to append the character at.
    /// @param buf_size The size of the buffer (will be changed if buffer is
    ///  reallocated)
    /// @param ch The character to append to the buffer.
    /// @warning This method may not be used for temporary buffers (buffers allocated
    ///  with icalmemory_tmp_buffer() and related functions)!
    ///
    /// @par Error handling
    /// Sets ::icalerrno to ::ICAL_BADARG_ERROR if @a buf, `*buf`, @a pos, `* pos`,
    /// or @a buf_size `NULL`.
    ///
    /// This method will copy the character @a ch and a `'\0'` character after it to
    /// the buffer @a buf starting at position @a pos, reallocing @a buf if it is too
    /// small. @a buf_size is the size of @a buf and will be changed if @a buf is
    /// reallocated. @a pos will point to the new terminating `'\0'` character @a
    /// buf.
    ///
    /// ### Example
    /// ```c
    /// // creates a new buffer
    /// int buffer_len = 15;
    /// char *buffer = icalmemory_new_buffer(buffer_len);
    /// strcpy(buffer, "My number is: ");
    ///
    /// // append a char to the buffer
    /// int buffer_end = strlen(buffer);
    /// char *buffer_end_pos = buffer[buffer_str_end];
    /// icalmemory_append_char(&buffer, &buffer_end_pos, &buffer_len, '7');
    ///
    /// // print string
    /// printf("%s\n", buffer);
    ///
    /// // release memory
    /// icalmemory_free_buffer(buffer);
    /// ```
    pub fn icalmemory_append_char(
        buf: *mut *mut ::std::os::raw::c_char,
        pos: *mut *mut ::std::os::raw::c_char,
        buf_size: *mut usize,
        ch: ::std::os::raw::c_char,
    );
}
extern "C" {
    /// @brief Create a duplicate of a string.
    /// @param s The string to duplicate.
    /// @return A pointer to a string containing the same data as @a s
    ///
    /// @par Error handling
    /// The string @a s must not be `NULL`, otherwise depending on the `libc` used,
    /// it might lead to undefined behaviour (read: segfaults).
    ///
    /// @par Ownership
    /// The returned string is owned by the caller and needs to be released with the
    /// appropriate `free()` method.
    ///
    /// A wrapper around `strdup()`.  Partly to trap calls to `strdup()`, partly
    /// because in `-ansi`, `gcc` on Red Hat claims that `strdup()` is undeclared.
    ///
    /// ### Usage
    /// ```c
    /// const char *my_str = "LibIcal";
    /// char *dup = icalmemory_strdup(my_str);
    /// printf("%s\n", dup);
    /// free(dup);
    /// ```
    pub fn icalmemory_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @brief Triggered before any error is called
    ///
    /// This routine is called before any error is triggered.
    /// It is called by icalerror_set_errno(), so it does not
    /// appear in all of the macros below.
    ///
    /// This routine can be used while debugging by setting
    /// a breakpoint here.
    pub fn icalerror_stop_here();
}
extern "C" {
    /// @brief Triggered to abort the process
    ///
    /// This routine is called to abort the process in the
    /// case of an error.
    pub fn icalerror_crash_here();
}
/// No error happened
pub const icalerrorenum_ICAL_NO_ERROR: icalerrorenum = 0;
/// A bad argument was passed to a function
pub const icalerrorenum_ICAL_BADARG_ERROR: icalerrorenum = 1;
/// An error occurred while creating a new object with a `*_new()` routine
pub const icalerrorenum_ICAL_NEWFAILED_ERROR: icalerrorenum = 2;
/// An error occurred while allocating some memory
pub const icalerrorenum_ICAL_ALLOCATION_ERROR: icalerrorenum = 3;
/// Malformed data was passed to a function
pub const icalerrorenum_ICAL_MALFORMEDDATA_ERROR: icalerrorenum = 4;
/// An error occurred while parsing part of an iCal component
pub const icalerrorenum_ICAL_PARSE_ERROR: icalerrorenum = 5;
/// An internal error happened in library code
pub const icalerrorenum_ICAL_INTERNAL_ERROR: icalerrorenum = 6;
/// An error happened while working with a file
pub const icalerrorenum_ICAL_FILE_ERROR: icalerrorenum = 7;
/// Failure to properly sequence calls to a set of interfaces
pub const icalerrorenum_ICAL_USAGE_ERROR: icalerrorenum = 8;
/// An unimplemented function was called
pub const icalerrorenum_ICAL_UNIMPLEMENTED_ERROR: icalerrorenum = 9;
/// An unknown error occurred
pub const icalerrorenum_ICAL_UNKNOWN_ERROR: icalerrorenum = 10;
/// @typedef icalerrorenum
/// @enum icalerrorenum
/// @brief Represents the different types of errors that
///  can be triggered in libical
///
/// Each of these values represent a different type of error, which
/// is stored in ::icalerrno on exit of the library function (or
/// can be returned, but if it is, ::icalerrno is also set).
pub type icalerrorenum = u32;
extern "C" {
    /// @brief Return the current ::icalerrno value
    /// @return A pointer to the current ::icalerrno value
    ///
    /// Yields a pointer to the current ::icalerrno value. This can
    /// be used to access (read from and write to) it.
    ///
    /// ### Examples
    /// ```c
    /// assert(*icalerrno_return() == icalerrno);
    /// ```
    pub fn icalerrno_return() -> *mut icalerrorenum;
}
extern "C" {
    /// @brief Change if errors are fatal
    /// @param fatal If true, libical aborts after a call to icalerror_set_error()
    /// @warning NOT THREAD SAFE: it is recommended that you do not change
    ///  this in a multithreaded program.
    ///
    /// ### Usage
    /// ```c
    /// icalerror_set_errors_are_fatal(true); // default
    /// icalerror_set_errors_are_fatal(false);
    /// ```
    pub fn icalerror_set_errors_are_fatal(fatal: ::std::os::raw::c_int);
}
extern "C" {
    /// @brief Determine if errors are fatal
    /// @return True if libical errors are fatal
    ///
    /// ### Usage
    /// ```c
    /// if(icalerror_get_errors_are_fatal()) {
    ///     // since errors are fatal, this will abort the
    ///     // program.
    ///     icalerror_set_errno(ICAL_PARSE_ERROR);
    /// }
    /// ```
    pub fn icalerror_get_errors_are_fatal() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Reset icalerrno to ::ICAL_NO_ERROR
    ///
    /// ### Usage
    /// ```c
    /// if(icalerrno == ICAL_PARSE_ERROR) {
    ///     // ignore parsing errors
    ///     icalerror_clear_errno();
    /// }
    /// ```
    pub fn icalerror_clear_errno();
}
/// Fatal
pub const icalerrorstate_ICAL_ERROR_FATAL: icalerrorstate = 0;
/// Non-fatal
pub const icalerrorstate_ICAL_ERROR_NONFATAL: icalerrorstate = 1;
/// Fatal if icalerror_errors_are_fatal(), non-fatal otherwise.
pub const icalerrorstate_ICAL_ERROR_DEFAULT: icalerrorstate = 2;
/// Asked state for an unknown error type
pub const icalerrorstate_ICAL_ERROR_UNKNOWN: icalerrorstate = 3;
/// @enum icalerrorstate
/// @typedef icalerrorstate
/// @brief Determine if an error is fatal or non-fatal.
pub type icalerrorstate = u32;
extern "C" {
    /// @brief Find description string for error
    /// @param e The type of error that occurred
    /// @return A string describing the error that occurred
    ///
    /// @par Error handling
    /// If the type of error @a e wasn't found, it returns the description
    /// for ::ICAL_UNKNOWN_ERROR.
    ///
    /// @par Ownership
    /// The string that is returned is owned by the library and must not
    /// be free'd() by the user.
    ///
    /// ### Usage
    /// ```c
    /// if(icalerrno != ICAL_NO_ERROR) {
    ///     printf("%s\n", icalerror_strerror(icalerrno));
    /// }
    /// ```
    pub fn icalerror_strerror(e: icalerrorenum) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Return the description string for the current error in ::icalerrno
    ///
    /// @par Error handling
    /// If the type of error @a e wasn't found, it returns the description
    /// for ::ICAL_UNKNOWN_ERROR.
    ///
    /// @par Ownership
    /// The string that is returned is owned by the library and must not
    /// be free'd() by the user.
    ///
    /// ### Usage
    /// ```c
    /// if(icalerrno != ICAL_NO_ERROR) {
    ///     printf("%s\n", icalerror_perror());
    /// }
    /// ```
    pub fn icalerror_perror() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @brief Prints backtrace
    /// @note Only works on systems that support it (HAVE_BACKTRACE enabled).
    ///
    /// ### Usage
    /// ```c
    /// if(icalerrno != ICAL_NO_ERROR) {
    ///     ical_bt();
    /// }
    /// ```
    pub fn ical_bt();
}
extern "C" {
    /// @brief Set the ::icalerrorstate for a given ::icalerrorenum @a error
    /// @param error The error to change
    /// @param state The new error state of the error
    ///
    /// Sets the severity of a given error. For example, it can be used to
    /// set the severity of an ::ICAL_PARSE_ERROR to be an ::ICAL_ERROR_NONFATAL.
    ///
    /// ### Usage
    /// ```c
    /// icalerror_set_error_state(ICAL_PARSE_ERROR, ICAL_ERROR_NONFATAL);
    /// ```
    pub fn icalerror_set_error_state(error: icalerrorenum, state: icalerrorstate);
}
extern "C" {
    /// @brief Get the error state (severity) for a given error
    /// @param error The error to examine
    /// @return Returns the severity of the error
    pub fn icalerror_get_error_state(error: icalerrorenum) -> icalerrorstate;
}
extern "C" {
    /// @brief Read an error from a string
    /// @param str The error name string
    /// @return An ::icalerrorenum representing the error
    ///
    /// @par Error handling
    /// If the error specified in @a str can't be found, instead
    /// ::ICAL_UNKNOWN_ERROR is returned.
    ///
    /// ### Usage
    /// ```c
    /// assert(icalerror_error_from_string("PARSE") == ICAL_PARSE_ERROR);
    /// assert(icalerror_error_from_string("NONSENSE") == ICAL_UNKNOWN_ERROR);
    /// ```
    pub fn icalerror_error_from_string(str: *const ::std::os::raw::c_char) -> icalerrorenum;
}
extern "C" {
    /// @brief Sets the ::icalerrno to a given error
    /// @param x The error to set ::icalerrno to
    ///
    /// Sets ::icalerrno to the error given in @a x. Additionally, if
    /// the error is an ::ICAL_ERROR_FATAL or if it's an ::ICAL_ERROR_DEFAULT
    /// and ::ICAL_ERRORS_ARE_FATAL is true, it prints a warning to @a stderr
    /// and aborts the process.
    ///
    /// ### Usage
    /// ```c
    /// icalerror_set_errno(ICAL_PARSE_ERROR);
    /// ```
    pub fn icalerror_set_errno(x: icalerrorenum);
}
extern "C" {
    /// @brief Suppresses a given error
    /// @param error The name of the error to suppress
    /// @return The previous icalerrorstate (severity)
    ///
    /// Calling this function causes the given error to be listed as
    /// ::ICAL_ERROR_NONFATAL, and thus suppressed. Error states can be
    /// restored with icalerror_restore().
    ///
    /// ### Usage
    /// ```c
    /// // suppresses internal errors
    /// icalerror_supress("INTERNAL");
    /// ```
    pub fn icalerror_supress(error: *const ::std::os::raw::c_char) -> icalerrorstate;
}
extern "C" {
    /// Assign the given error the given icalerrorstate (severity)
    /// @param error The error in question
    /// @param es The icalerrorstate (severity) to set it to
    ///
    /// Calling the function changes the ::icalerrorstate of the given error.
    ///
    /// ### Usage
    /// ```c
    /// // suppress internal errors
    /// icalerror_supress("INTERNAL");
    ///
    /// // ...
    ///
    /// // restore internal errors
    /// icalerror_restore("INTERNAL", ICAL_ERROR_DEFAULT);
    /// ```
    pub fn icalerror_restore(error: *const ::std::os::raw::c_char, es: icalerrorstate);
}
/// No restriction
pub const icalrestriction_kind_ICAL_RESTRICTION_NONE: icalrestriction_kind = 0;
/// Zero
pub const icalrestriction_kind_ICAL_RESTRICTION_ZERO: icalrestriction_kind = 1;
/// One
pub const icalrestriction_kind_ICAL_RESTRICTION_ONE: icalrestriction_kind = 2;
/// Zero or more
pub const icalrestriction_kind_ICAL_RESTRICTION_ZEROPLUS: icalrestriction_kind = 3;
/// One or more
pub const icalrestriction_kind_ICAL_RESTRICTION_ONEPLUS: icalrestriction_kind = 4;
/// Zero or one
pub const icalrestriction_kind_ICAL_RESTRICTION_ZEROORONE: icalrestriction_kind = 5;
/// Zero or one, exclusive with another property
pub const icalrestriction_kind_ICAL_RESTRICTION_ONEEXCLUSIVE: icalrestriction_kind = 6;
/// Zero or one, mutual with another property
pub const icalrestriction_kind_ICAL_RESTRICTION_ONEMUTUAL: icalrestriction_kind = 7;
/// Unknown
pub const icalrestriction_kind_ICAL_RESTRICTION_UNKNOWN: icalrestriction_kind = 8;
/// @brief The kinds of icalrestrictions there are
///
/// These must stay in this order for icalrestriction_compare to work
pub type icalrestriction_kind = u32;
extern "C" {
    /// @brief Checks if the given @a count is in accordance with the given
    ///  restriction, @a restr.
    /// @param restr The restriction to apply to the @a count
    /// @param count The amount present that is to be checked against the restriction
    /// @return 1 if the restriction is met, 0 if not
    ///
    /// ### Example
    /// ```c
    /// assert(icalrestriction_compare(ICALRESTRICTION_ONEPLUS, 5) == true);
    /// assert(icalrestriction_compare(ICALRESTRICTION_NONE,    3) == false);
    /// ```
    pub fn icalrestriction_compare(
        restr: icalrestriction_kind,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Checks if a given `VCALENDAR` meets all the restrictions imposed by
    ///  the standard.
    /// @param comp The `VCALENDAR` component to check
    /// @return 1 if the restrictions are met, 0 if not
    ///
    /// @par Error handling
    /// Returns 0 and sets ::icalerrno if `NULL` is passed as @a comp, or if the
    /// component is not a `VCALENDAR`.
    ///
    /// ### Example
    /// ```c
    /// icalcomponent *component = // ...
    ///
    /// // check component
    /// assert(icalrestriction_check(component) == true);
    /// ```
    pub fn icalrestriction_check(comp: *mut icalcomponent) -> ::std::os::raw::c_int;
}
pub const sspm_major_type_SSPM_NO_MAJOR_TYPE: sspm_major_type = 0;
pub const sspm_major_type_SSPM_TEXT_MAJOR_TYPE: sspm_major_type = 1;
pub const sspm_major_type_SSPM_IMAGE_MAJOR_TYPE: sspm_major_type = 2;
pub const sspm_major_type_SSPM_AUDIO_MAJOR_TYPE: sspm_major_type = 3;
pub const sspm_major_type_SSPM_VIDEO_MAJOR_TYPE: sspm_major_type = 4;
pub const sspm_major_type_SSPM_APPLICATION_MAJOR_TYPE: sspm_major_type = 5;
pub const sspm_major_type_SSPM_MULTIPART_MAJOR_TYPE: sspm_major_type = 6;
pub const sspm_major_type_SSPM_MESSAGE_MAJOR_TYPE: sspm_major_type = 7;
pub const sspm_major_type_SSPM_UNKNOWN_MAJOR_TYPE: sspm_major_type = 8;
pub type sspm_major_type = u32;
pub const sspm_minor_type_SSPM_NO_MINOR_TYPE: sspm_minor_type = 0;
pub const sspm_minor_type_SSPM_ANY_MINOR_TYPE: sspm_minor_type = 1;
pub const sspm_minor_type_SSPM_PLAIN_MINOR_TYPE: sspm_minor_type = 2;
pub const sspm_minor_type_SSPM_RFC822_MINOR_TYPE: sspm_minor_type = 3;
pub const sspm_minor_type_SSPM_DIGEST_MINOR_TYPE: sspm_minor_type = 4;
pub const sspm_minor_type_SSPM_CALENDAR_MINOR_TYPE: sspm_minor_type = 5;
pub const sspm_minor_type_SSPM_MIXED_MINOR_TYPE: sspm_minor_type = 6;
pub const sspm_minor_type_SSPM_RELATED_MINOR_TYPE: sspm_minor_type = 7;
pub const sspm_minor_type_SSPM_ALTERNATIVE_MINOR_TYPE: sspm_minor_type = 8;
pub const sspm_minor_type_SSPM_PARALLEL_MINOR_TYPE: sspm_minor_type = 9;
pub const sspm_minor_type_SSPM_UNKNOWN_MINOR_TYPE: sspm_minor_type = 10;
pub type sspm_minor_type = u32;
pub const sspm_encoding_SSPM_NO_ENCODING: sspm_encoding = 0;
pub const sspm_encoding_SSPM_QUOTED_PRINTABLE_ENCODING: sspm_encoding = 1;
pub const sspm_encoding_SSPM_8BIT_ENCODING: sspm_encoding = 2;
pub const sspm_encoding_SSPM_7BIT_ENCODING: sspm_encoding = 3;
pub const sspm_encoding_SSPM_BINARY_ENCODING: sspm_encoding = 4;
pub const sspm_encoding_SSPM_BASE64_ENCODING: sspm_encoding = 5;
pub const sspm_encoding_SSPM_UNKNOWN_ENCODING: sspm_encoding = 6;
pub type sspm_encoding = u32;
pub const sspm_error_SSPM_NO_ERROR: sspm_error = 0;
pub const sspm_error_SSPM_UNEXPECTED_BOUNDARY_ERROR: sspm_error = 1;
pub const sspm_error_SSPM_WRONG_BOUNDARY_ERROR: sspm_error = 2;
pub const sspm_error_SSPM_NO_BOUNDARY_ERROR: sspm_error = 3;
pub const sspm_error_SSPM_NO_HEADER_ERROR: sspm_error = 4;
pub const sspm_error_SSPM_MALFORMED_HEADER_ERROR: sspm_error = 5;
pub type sspm_error = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sspm_header {
    pub def: ::std::os::raw::c_int,
    pub boundary: *mut ::std::os::raw::c_char,
    pub major: sspm_major_type,
    pub minor: sspm_minor_type,
    pub minor_text: *mut ::std::os::raw::c_char,
    pub content_type_params: *mut *mut ::std::os::raw::c_char,
    pub charset: *mut ::std::os::raw::c_char,
    pub encoding: sspm_encoding,
    pub filename: *mut ::std::os::raw::c_char,
    pub content_id: *mut ::std::os::raw::c_char,
    pub error: sspm_error,
    pub error_text: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sspm_header() {
    assert_eq!(
        ::std::mem::size_of::<sspm_header>(),
        88usize,
        concat!("Size of: ", stringify!(sspm_header))
    );
    assert_eq!(
        ::std::mem::align_of::<sspm_header>(),
        8usize,
        concat!("Alignment of ", stringify!(sspm_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).def as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).boundary as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(boundary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).major as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).minor as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).minor_text as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(minor_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).content_type_params as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(content_type_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).charset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(charset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).encoding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).filename as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).content_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(content_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).error as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_header>())).error_text as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_header),
            "::",
            stringify!(error_text)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sspm_part {
    pub header: sspm_header,
    pub level: ::std::os::raw::c_int,
    pub data_size: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sspm_part() {
    assert_eq!(
        ::std::mem::size_of::<sspm_part>(),
        112usize,
        concat!("Size of: ", stringify!(sspm_part))
    );
    assert_eq!(
        ::std::mem::align_of::<sspm_part>(),
        8usize,
        concat!("Alignment of ", stringify!(sspm_part))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_part>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_part),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_part>())).level as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_part),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_part>())).data_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_part),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_part>())).data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_part),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sspm_action_map {
    pub major: sspm_major_type,
    pub minor: sspm_minor_type,
    pub new_part: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub add_line: ::std::option::Option<
        unsafe extern "C" fn(
            part: *mut ::std::os::raw::c_void,
            header: *mut sspm_header,
            line: *const ::std::os::raw::c_char,
            size: usize,
        ),
    >,
    pub end_part: ::std::option::Option<
        unsafe extern "C" fn(part: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub free_part: ::std::option::Option<unsafe extern "C" fn(part: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_sspm_action_map() {
    assert_eq!(
        ::std::mem::size_of::<sspm_action_map>(),
        40usize,
        concat!("Size of: ", stringify!(sspm_action_map))
    );
    assert_eq!(
        ::std::mem::align_of::<sspm_action_map>(),
        8usize,
        concat!("Alignment of ", stringify!(sspm_action_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).new_part as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(new_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).add_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(add_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).end_part as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(end_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sspm_action_map>())).free_part as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sspm_action_map),
            "::",
            stringify!(free_part)
        )
    );
}
extern "C" {
    pub fn sspm_major_type_string(type_: sspm_major_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sspm_minor_type_string(type_: sspm_minor_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sspm_encoding_string(type_: sspm_encoding) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sspm_parse_mime(
        parts: *mut sspm_part,
        max_parts: usize,
        actions: *const sspm_action_map,
        get_string: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut ::std::os::raw::c_char,
                size: usize,
                data: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_char,
        >,
        get_string_data: *mut ::std::os::raw::c_void,
        first_header: *mut sspm_header,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sspm_free_parts(parts: *mut sspm_part, max_parts: usize);
}
extern "C" {
    pub fn decode_quoted_printable(
        dest: *mut ::std::os::raw::c_char,
        src: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decode_base64(
        dest: *mut ::std::os::raw::c_char,
        src: *mut ::std::os::raw::c_char,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sspm_write_mime(
        parts: *mut sspm_part,
        num_parts: usize,
        output_string: *mut *mut ::std::os::raw::c_char,
        header: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icalmime_parse(
        line_gen_func: ::std::option::Option<
            unsafe extern "C" fn(
                s: *mut ::std::os::raw::c_char,
                size: usize,
                d: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_char,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut icalcomponent;
}
extern "C" {
    pub fn icallangbind_new_array(size: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn icallangbind_free_array(array: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn icallangbind_access_array(
        array: *mut ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icallangbind_get_first_property(
        c: *mut icalcomponent,
        prop: *const ::std::os::raw::c_char,
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icallangbind_get_next_property(
        c: *mut icalcomponent,
        prop: *const ::std::os::raw::c_char,
    ) -> *mut icalproperty;
}
extern "C" {
    pub fn icallangbind_get_first_component(
        c: *mut icalcomponent,
        comp: *const ::std::os::raw::c_char,
    ) -> *mut icalcomponent;
}
extern "C" {
    pub fn icallangbind_get_next_component(
        c: *mut icalcomponent,
        comp: *const ::std::os::raw::c_char,
    ) -> *mut icalcomponent;
}
extern "C" {
    pub fn icallangbind_get_first_parameter(prop: *mut icalproperty) -> *mut icalparameter;
}
extern "C" {
    pub fn icallangbind_get_next_parameter(prop: *mut icalproperty) -> *mut icalparameter;
}
extern "C" {
    pub fn icallangbind_property_eval_string(
        prop: *mut icalproperty,
        sep: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icallangbind_property_eval_string_r(
        prop: *mut icalproperty,
        sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn icallangbind_string_to_open_flag(
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn icallangbind_quote_as_ical(
        str: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn icallangbind_quote_as_ical_r(
        str: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
